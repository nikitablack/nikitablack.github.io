<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>DirectX 12 by example | Here should be the blog Title</title>



<link href="http://nikitablack.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Here should be the blog Title" />

<link rel="stylesheet" href="/css/style.css"/>
<link rel="stylesheet" href="/css/css_lightbox.css"><link rel='stylesheet' href='http://nikitablack.github.io/css/custom.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="http://nikitablack.github.io/post/directx_12_by_example/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>

<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="http://nikitablack.github.io/">
          <h1 id="nav-heading" class="title is-4">Here should be the blog Title</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="twitter" href='https://twitter.com/nikita_cherniy'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="github" href='https://github.com/nikitablack'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:mynameisnikitablack@gmail.com'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
    </div>
    <h2 class="subtitle is-6">June 23, 2016</h2>
    <h1 class="title">DirectX 12 by example</h1>
    
    <div class="content">
      <h4 id="disclaimer">Disclaimer!</h4>
<p>I&rsquo;m not an expert, computer graphics is my hobby. When I started to learn directx 12 I already was quite comfortable with directx 11 but it was still difficult to switch. And even after several months of investigations I still have a feeling that I just scratched a surface. I&rsquo;m constantly learning and this post is a synchronization of my thoughts. I found that attempts to explain complex things makes me understand these things better. Thought the article was written by me for me I hope you&rsquo;ll find it useful too.</p>
<p>Directx 12 is low level, it has many concepts and in order to make your code work well you need to take into account a lot of things. You need to profile a lot. And you need to know hardware. For example you need to know that changing descriptor heaps is a heavy operation. I have no idea what&rsquo;s happening in hardware and why it&rsquo;s expensive. I&rsquo;m just following guidelines trying to remember and reading gpu specs in parallel.</p>
<p>Also I assume that you have an experience with previous directx versions because I&rsquo;ll not explain in this post what is swapchain or backbuffer. You should be familar with tesselation - what are tesselation factors, what is a constant function, why do you need hull and domain shaders. Good overview of directx 11 tesselation can be found <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff476340(v=vs.85).aspx">here</a>. Also you need to know basic windows programming because we need to create a window and I&rsquo;ll not explain how to do it.</p>
<h4 id="preface">Preface</h4>
<p>In this tutorial we&rsquo;ll render a teapot. But not just a static mesh, no. We&rsquo;ll render a tesselated teapot. Why did I choose this? Well, because you can find in the web a plenty of different <em>HelloWorld</em> examples. I didn&rsquo;t want to create another <em>HelloWorld</em> but something that covers different areas of the api and at the same time is simple.</p>
<a href="#images%2fteapot.png">
    <img src=images/teapot.png class="thumbnail">
</a>
</br>
  

<a href="#_" class="lightbox" id="images/teapot.png">
  <img src=images/teapot.png>
</a>
<p>We&rsquo;re going to use <code>16</code>-point patches for the teapot. We&rsquo;ll provide control points positions in one vertex buffer and patch indicies in one index buffer. For colors and transforms (more on this later) we&rsquo;ll use structured buffers.</p>
<p>Usually directx tutorials follow the same pattern - initialization, resource creation, rendering. I decided to go slightly different way - first we&rsquo;ll create the most important part and later will add different components to support it - one after another as required. And the most important part, by my opinion, are shaders. After all this is what we want the gpu to execute. This approach helped me to tie different parts of the api and undesrtand how they related to each other.</p>
<p>In order to write a shader we need to figure out what data it operates on. So let&rsquo;s first define it.</p>
<h4 id="teapot-data">Teapot Data</h4>
<p>Since we&rsquo;re going to use tesselation we&rsquo;re not interested in <em>&ldquo;usual&rdquo;</em> mesh made of triangles. We need patches. Of course somebody already did this for us and we can use ready data. For example <a href="https://www.sjbaker.org/wiki/index.php?title=The_History_of_The_Teapot#The_Teapot_DataSet">here</a> is the set of <code>16</code>-point patches that describe a teapot. Unfortunatelly we can&rsquo;t use this data as is but we need to adjust it a little. This set doesn&rsquo;t have a bottom - it&rsquo;s ok, we&rsquo;ll not use it either but existing patches describe only parts of the teapot. For example <em>rim</em>, <em>body</em> and <em>lid</em> describe only a quarter of a teapot and <em>handle</em> and <em>spout</em> describe only half of respective parts. So if we&rsquo;ll render this set we&rsquo;ll get this:</p>
<a href="#images%2fteapot_quarter.png">
    <img src=images/teapot_quarter.png class="thumbnail">
</a>
</br>
  

<a href="#_" class="lightbox" id="images/teapot_quarter.png">
  <img src=images/teapot_quarter.png>
</a>
<p>There&rsquo;re several ways to fix it. One way is to use separate draw call for every part. This way we can render rim four times with different transformations. Another way is to draw a part once but use instancing. This way we&rsquo;ll have a draw call for every part&rsquo;s family (<em>rim</em>, <em>body</em> etc.) but the repeated parts will be instances.</p>
<p>We&rsquo;ll go other way and render everything in one draw call. For this we&rsquo;ll duplicate indices required number of times and also provide a transformation for every part. Let&rsquo;s take a rim as an example. Instead of having one patch for the quarter we&rsquo;ll have <code>4</code> patches for the entire circle, that means <code>16 * 4 = 64</code> indices for this part. In the shader knowing the patch id we can apply a transform. In our case we&rsquo;ll rotate initial patch around an axis by <code>0</code>, <code>90</code>, <code>180</code> and <code>270</code> degrees. All that means that together with points positions and indices we need to provide a transformation data as. Additionally to visually separate patches we&rsquo;ll use different colors which also should be provided as a separate data. In total we&rsquo;ll have <code>28</code> patches and our data will consist of list of points (some points are shared between patches - that&rsquo;s why we need indices), list of indices (<code>28 * 16</code>), list of transforms (<code>28</code> matrices) and list of colors (<code>28</code> randomly generated rgb colors). Final data can be found <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/TeapotData.cpp">here</a>.</p>
<h4 id="shaders">Shaders</h4>
<p>In our example we&rsquo;ll use vertex, hull, domain and pixel shaders.</p>
<p><strong>Vertex shader</strong></p>
<p>The first shader in our pipeline is the vertex shader. All it&rsquo;s do is accepts control point position from the application and passes it to the hull shader. Because of its simplicity I&rsquo;ll not provide it here but you can observe it in <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/VertexShader.hlsl">github</a>.</p>
<p>Just to remind you - the vertex shader will be called once for every control point in the patch. For <code>28</code> patches (recall that this is the number of patches used for the model) <code>16</code> points each this is <code>448</code> times.</p>
<p><strong>Hull shader</strong></p>
<p>This shader, as you already know, receives control point position from the vertex shader and also some data from the application in the form of constants which we&rsquo;ll use as tesseltion factors for edge and inside of the patch.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#099">#define NUM_CONTROL_POINTS 16
</span><span style="color:#099"></span>
<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">PatchTesselationFactors</span>
{
	<span style="color:#078;font-weight:bold">int</span> edge;
	<span style="color:#078;font-weight:bold">int</span> inside;
};
ConstantBuffer<span style="color:#555">&lt;</span>PatchTesselationFactors<span style="color:#555">&gt;</span> <span style="color:#99f">tessFactors</span> : <span style="color:#069;font-weight:bold">register</span>(b0);

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">VertexToHull</span>
{
	float3 <span style="color:#99f">pos</span> : POSITION;
};

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">PatchConstantData</span>
{
	<span style="color:#078;font-weight:bold">float</span> edgeTessFactor[<span style="color:#f60">4</span>] <span style="color:#555">:</span> SV_TessFactor;
	<span style="color:#078;font-weight:bold">float</span> insideTessFactor[<span style="color:#f60">2</span>] <span style="color:#555">:</span> SV_InsideTessFactor;
};

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">HullToDomain</span>
{
	float3 <span style="color:#99f">pos</span> : POSITION;
};

PatchConstantData <span style="color:#c0f">calculatePatchConstants</span>()
{
	PatchConstantData output;

	output.edgeTessFactor[<span style="color:#f60">0</span>] <span style="color:#555">=</span> tessFactors.edge;
	output.edgeTessFactor[<span style="color:#f60">1</span>] <span style="color:#555">=</span> tessFactors.edge;
	output.edgeTessFactor[<span style="color:#f60">2</span>] <span style="color:#555">=</span> tessFactors.edge;
	output.edgeTessFactor[<span style="color:#f60">3</span>] <span style="color:#555">=</span> tessFactors.edge;
	output.insideTessFactor[<span style="color:#f60">0</span>] <span style="color:#555">=</span> tessFactors.inside;
	output.insideTessFactor[<span style="color:#f60">1</span>] <span style="color:#555">=</span> tessFactors.inside;

	<span style="color:#069;font-weight:bold">return</span> output;
}

[domain(<span style="color:#c30">&#34;quad&#34;</span>)]
[partitioning(<span style="color:#c30">&#34;integer&#34;</span>)]
[outputtopology(<span style="color:#c30">&#34;triangle_cw&#34;</span>)]
[outputcontrolpoints(NUM_CONTROL_POINTS)]
[patchconstantfunc(<span style="color:#c30">&#34;calculatePatchConstants&#34;</span>)]
HullToDomain main(InputPatch<span style="color:#555">&lt;</span>VertexToHull, NUM_CONTROL_POINTS<span style="color:#555">&gt;</span> input, uint <span style="color:#99f">i</span> : SV_OutputControlPointID)
{
	HullToDomain output;
	output.pos <span style="color:#555">=</span> input[i].pos;

	<span style="color:#069;font-weight:bold">return</span> output;
}</code></pre></div>
<p>Here you can see that the patch outputs the same <code>16</code> control points, uses <code>integer</code> partitioning and <code>quad</code> domain. Also note the new <code>hlsl 5.1</code> syntax for the constant buffer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ConstantBuffer<span style="color:#555">&lt;</span>PatchTesselationFactors<span style="color:#555">&gt;</span> <span style="color:#99f">tessFactors</span> : <span style="color:#069;font-weight:bold">register</span>(b0);</code></pre></div>
<p>Thought you can use the old syntax I like the new one more. Beyond this the shader is a simple pass-through, like a vertex shader.</p>
<p>This shader will be invoked <code>28</code> number of times (by the number of patches).</p>
<p><strong>Domain shader</strong></p>
<p>Finally we arrived to the point of interest. Basically this is the place where all the work is done in our program.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#099">#define NUM_CONTROL_POINTS 16
</span><span style="color:#099"></span>
<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">ConstantBufferPerObj</span>
{
	row_major float4x4 wvpMat;
};
ConstantBuffer<span style="color:#555">&lt;</span>ConstantBufferPerObj<span style="color:#555">&gt;</span> <span style="color:#99f">constPerObject</span> : <span style="color:#069;font-weight:bold">register</span>(b0);

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">PatchTransform</span>
{
	row_major float4x4 transform;
};
StructuredBuffer<span style="color:#555">&lt;</span>PatchTransform<span style="color:#555">&gt;</span> <span style="color:#99f">patchTransforms</span> : <span style="color:#069;font-weight:bold">register</span>(t0);

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">PatchColor</span>
{
	float3 color;
};
StructuredBuffer<span style="color:#555">&lt;</span>PatchColor<span style="color:#555">&gt;</span> <span style="color:#99f">patchColors</span> : <span style="color:#069;font-weight:bold">register</span>(t1);

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">PatchConstantData</span>
{
	<span style="color:#078;font-weight:bold">float</span> edgeTessFactor[<span style="color:#f60">4</span>] <span style="color:#555">:</span> SV_TessFactor;
	<span style="color:#078;font-weight:bold">float</span> insideTessFactor[<span style="color:#f60">2</span>] <span style="color:#555">:</span> SV_InsideTessFactor;
};

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">HullToDomain</span>
{
	float3 <span style="color:#99f">pos</span> : POSITION;
};

<span style="color:#069;font-weight:bold">struct</span> <span style="color:#0a8;font-weight:bold">DomainToPixel</span>
{
	float4 <span style="color:#99f">pos</span> : SV_POSITION;
	float3 <span style="color:#99f">color</span> : COLOR;
};

float4 <span style="color:#c0f">bernsteinBasis</span>(<span style="color:#078;font-weight:bold">float</span> t)
{
	<span style="color:#078;font-weight:bold">float</span> invT <span style="color:#555">=</span> <span style="color:#f60">1.0f</span> <span style="color:#555">-</span> t;
	<span style="color:#069;font-weight:bold">return</span> float4(invT <span style="color:#555">*</span> invT <span style="color:#555">*</span> invT, <span style="color:#09f;font-style:italic">// (1-t)3
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#f60">3.0f</span> <span style="color:#555">*</span> t <span style="color:#555">*</span> invT <span style="color:#555">*</span> invT, <span style="color:#09f;font-style:italic">// 3t(1-t)2
</span><span style="color:#09f;font-style:italic"></span>		<span style="color:#f60">3.0f</span> <span style="color:#555">*</span> t <span style="color:#555">*</span> t <span style="color:#555">*</span> invT, <span style="color:#09f;font-style:italic">// 3t2(1-t)
</span><span style="color:#09f;font-style:italic"></span>		t <span style="color:#555">*</span> t <span style="color:#555">*</span> t); <span style="color:#09f;font-style:italic">// t3
</span><span style="color:#09f;font-style:italic"></span>}

float3 <span style="color:#c0f">evaluateBezier</span>(<span style="color:#069;font-weight:bold">const</span> OutputPatch<span style="color:#555">&lt;</span>HullToDomain, NUM_CONTROL_POINTS<span style="color:#555">&gt;</span> bezpatch, float4 basisU, float4 basisV)
{
	float3 value <span style="color:#555">=</span> float3(<span style="color:#f60">0</span>, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>);
	value <span style="color:#555">=</span> basisV.x <span style="color:#555">*</span> (bezpatch[<span style="color:#f60">0</span>].pos <span style="color:#555">*</span> basisU.x <span style="color:#555">+</span> bezpatch[<span style="color:#f60">1</span>].pos <span style="color:#555">*</span> basisU.y <span style="color:#555">+</span> bezpatch[<span style="color:#f60">2</span>].pos <span style="color:#555">*</span> basisU.z <span style="color:#555">+</span> bezpatch[<span style="color:#f60">3</span>].pos <span style="color:#555">*</span> basisU.w);
	value <span style="color:#555">+=</span> basisV.y <span style="color:#555">*</span> (bezpatch[<span style="color:#f60">4</span>].pos <span style="color:#555">*</span> basisU.x <span style="color:#555">+</span> bezpatch[<span style="color:#f60">5</span>].pos <span style="color:#555">*</span> basisU.y <span style="color:#555">+</span> bezpatch[<span style="color:#f60">6</span>].pos <span style="color:#555">*</span> basisU.z <span style="color:#555">+</span> bezpatch[<span style="color:#f60">7</span>].pos <span style="color:#555">*</span> basisU.w);
	value <span style="color:#555">+=</span> basisV.z <span style="color:#555">*</span> (bezpatch[<span style="color:#f60">8</span>].pos <span style="color:#555">*</span> basisU.x <span style="color:#555">+</span> bezpatch[<span style="color:#f60">9</span>].pos <span style="color:#555">*</span> basisU.y <span style="color:#555">+</span> bezpatch[<span style="color:#f60">10</span>].pos <span style="color:#555">*</span> basisU.z <span style="color:#555">+</span> bezpatch[<span style="color:#f60">11</span>].pos <span style="color:#555">*</span> basisU.w);
	value <span style="color:#555">+=</span> basisV.w <span style="color:#555">*</span> (bezpatch[<span style="color:#f60">12</span>].pos <span style="color:#555">*</span> basisU.x <span style="color:#555">+</span> bezpatch[<span style="color:#f60">13</span>].pos <span style="color:#555">*</span> basisU.y <span style="color:#555">+</span> bezpatch[<span style="color:#f60">14</span>].pos <span style="color:#555">*</span> basisU.z <span style="color:#555">+</span> bezpatch[<span style="color:#f60">15</span>].pos <span style="color:#555">*</span> basisU.w);

	<span style="color:#069;font-weight:bold">return</span> value;
}

[domain(<span style="color:#c30">&#34;quad&#34;</span>)]
DomainToPixel main(PatchConstantData input, float2 <span style="color:#99f">domain</span> : SV_DomainLocation, <span style="color:#069;font-weight:bold">const</span> OutputPatch<span style="color:#555">&lt;</span>HullToDomain, NUM_CONTROL_POINTS<span style="color:#555">&gt;</span> patch, uint <span style="color:#99f">patchID</span> : SV_PrimitiveID)
{
	<span style="color:#09f;font-style:italic">// Evaluate the basis functions at (u, v)
</span><span style="color:#09f;font-style:italic"></span>	float4 basisU <span style="color:#555">=</span> bernsteinBasis(domain.x);
	float4 basisV <span style="color:#555">=</span> bernsteinBasis(domain.y);

	<span style="color:#09f;font-style:italic">// Evaluate the surface position for this vertex
</span><span style="color:#09f;font-style:italic"></span>	float3 localPos <span style="color:#555">=</span> evaluateBezier(patch, basisU, basisV);

	float4x4 transform <span style="color:#555">=</span> patchTransforms[patchID].transform;
	float4 localPosTransformed <span style="color:#555">=</span> mul(float4(localPos, <span style="color:#f60">1.0f</span>), transform);

	DomainToPixel output;
	output.pos <span style="color:#555">=</span> mul(localPosTransformed, constPerObject.wvpMat);
	output.color <span style="color:#555">=</span> patchColors[patchID].color;

	<span style="color:#069;font-weight:bold">return</span> output;
}</code></pre></div>
<p>Going from the top we see that we&rsquo;re operating on the same <code>16</code> point patch, we have a constant buffer for the teapot`s world-view-projection transform, structured buffer for the patch transform and structured buffer for the patch color. In practice we can use one structured buffer for both transforms and colors but I deliberately split it in two to show how we can assign resources through the root table (more on this later). This data we&rsquo;re receiving from the application.</p>
<p>There&rsquo;re also structs: <code>PatchConstantData</code> and <code>HullToDomain</code> - data from the hull shader (remember that position is a pass through from the vertex shader which also passes it from the input assembler), <code>DomainToPixel</code> - the data we&rsquo;re passing further down the pipeline - to the pixel shader.</p>
<p>Next is a pure math - in the <code>main()</code> function we have a list of control points for one patch (<code>16</code> points) and we need to sample it so we can assign a position to the new vertex generated by tesselator. The good overview of the math behind you can find <a href="http://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php">here</a>. Also <a href="http://www.gdcvault.com/play/1012740/direct3d">this presentation</a> is a very good reading about patch tesselation in <code>directx 11</code> (I took the most of the code from there to be honest).</p>
<p>So what are we doing in the <code>main()</code> function? The first <code>3</code> function parameters are pretty standard - the constant data which we defined in the hull shader (not used here, but have to be provided), <code>uv</code> coordinates for our point in the quad domain - generated by tesselator, and initial patch information from the hull shader. The last parameter - <code>PatchID</code> with special semantics is worth paying litle attention. As you remember, in our demo we have the total number of patches equal to <code>28</code> and we want to apply some parameters to each patch, for example a color. That means that for every generated vertex in the same patch we need to assign the same color information and pass it to the <code>pixel</code> shader. And this is where <code>SV_PrimitiveID</code> semantics will come to the rescue - for every vertex of the same patch (no matter how many vertices were generated) this value will be the same. The first patch will get id of <code>0</code>, second patch - <code>1</code> and so on. One thing worth to remember - all patches should be rendered in one draw call. Every new draw call resets the id (as well as new instance in instance drawing).</p>
<p>First we&rsquo;re finding the vertex position in patch space. Next with the help of the patch id we&rsquo;re obtaining th patch transform (recall an example - we need to rotate a rim <code>4</code> times) and applying it to the vertex. Next we&rsquo;re transforming the vertex to the homogenious space by multiplying it on world-view-projection matrix. In the final step we&rsquo;re sampling the color structured buffer and sending this data to our last programmable stage - pixel shader.</p>
<p>This function will be called for every generated vertex (generated by tesselator). The number of generated vertices depends on the tesselation factors (edge and inside for the quad patch) and partitioning scheme (<code>[partitioning(&quot;integer&quot;)]</code> in the hull shader).</p>
<p><strong>Pixel shader</strong></p>
<p>This is also a very simple shader, don&rsquo;t even need to be discussed. You can find the code <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/PixelShader.hlsl">here</a>.</p>
<p>That&rsquo;s basically it - we have a program and we need to make our hardware to run it. All other code just exist for this purpose - to help the gpu execute shaders. To summarize things I drew a diagram that shows shader stages and resources we need.</p>
<a href="#images%2fshader_res_1.png">
    <img src=images/shader_res_1.png class="thumbnail">
</a>
</br>
  

<a href="#_" class="lightbox" id="images/shader_res_1.png">
  <img src=images/shader_res_1.png>
</a>
<p>Couple of things to note. Resources are stored in gpu memory. Gpu have no idea what&rsquo;s stored inside it and how to interpret it - it&rsquo;s just a blob of data. It&rsquo;s our task to tell it where the data resides, the size and the format. For vertex buffer and index buffer it&rsquo;s pretty easy - we&rsquo;re creating these buffers and later tell the gpu to use it with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn986883(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::IASetVertexBuffers()</code></a> and <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn986882(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::IASetIndexBuffer()</code></a> methods. On the diagram I showed solid a arrow from input to these resources. With other resources things are different. There&rsquo;s no such method like <code>DSSetStructuredBufferInSlot()</code> or similar and we need to use a special structure called <code>RootSignature</code> to bind shaders and resources together. That&rsquo;s why there&rsquo;re question marks between shader and resource. We&rsquo;ll find out how to bind resources in the next sections. Also on the diagram I specified the size of our data together with alignment size (for example <code>1416B / 64kB</code> for the <code>vertex buffer</code>). Id directx 12 (and 11) buffers should be aligned by <code>64kB</code>. We can specify this value during resource creation or let the api do it for us. That means if we have a lot of small buffers we&rsquo;re wasting a lot of space. But it&rsquo;s just an interesting point and we shoudn&rsquo;t bother about this in our example.</p>
<h4 id="briefly-about-descriptors">Briefly about Descriptors</h4>
<p>As I mentioned above gpu can&rsquo;t use resource memory directly. How can we say then that some memory is a structured buffer, for example? As you already guessed - with a descriptor (another name is view). This is a small structure that describes the resource - it&rsquo;s format, size etc. Since this information used by gpu it&rsquo;s convenient to strore it in the gpu itself. We keep descriptors in special place called descriptor heap. We&rsquo;ll touch descriptors more closely in later sections but for now you just need to remember that resource stored in memory is just a bunch on bits and bytes. This bunch can be described with descriptors - lightweight data that tells gpu how to interpret particular part of memory. This descriptors are stored in gpu memory in descriptor heaps. Of course directx wouldn&rsquo;t be directx if everything would be so easy - there different ways to provide information to the gpu, for example we can bypass descriptor heap and pass descriptor directly or avoid desciptor at all! We&rsquo;ll cover this options in the course of this article.</p>
<h4 id="code-organization">Code Organization</h4>
<p>When I started to write this tutorial I wanted to make it as simple as possible and put everything in one file. But when this file became more than <code>1000</code> lines I decided to split the code on several logic units. <code>Window</code> is a class which encapsulates window creation and accepts a key press callback in the form of <code>std::function</code>. We&rsquo;ll use this callback to change demo parameters. <code>Graphics</code> is a base class for our demo. It creates a <code>Window</code> and also initializes d3d. For example it creates device, swap chain, depth buffer, back buffers, command list and so on. <code>TeapotTutorial</code> extends this class and adds functionality related to our demo - resources creation, rendering. I&rsquo;ll describe why each method exist and we&rsquo;ll start with creation of the root signature.</p>
<h4 id="root-signature">Root Signature</h4>
<p>At this point we should know that shaders require resources and this resources should be bound to the correct resource slots (<code>b0</code> for constant buffer, <code>t0</code> for structured buffer, for example). In directx 12 we bind with special interface - <code>ID3D12RootSignature</code>. With the help of the interface we can describe which resources a shader needs and in which slot. We can say that signature only declares input parameters, just like usual c++ function signature. For example:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#078;font-weight:bold">void</span> <span style="color:#c0f">rootSignature</span>(std<span style="color:#555">::</span>array<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">int</span>, <span style="color:#f60">2</span><span style="color:#555">&gt;</span> constants, XMFLOAT4X4<span style="color:#555">*</span> wvpMatrix, std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>XMFLOAT3<span style="color:#555">*&gt;*</span> colors);</code></pre></div>
<p>What we see here is that our function expects <code>3</code> parameters - two ints, copied by value; pointer to a matrix, and a pointer to vector of pointers to some colors. This is what happening if we&rsquo;re using these values: the first parameter - two ints - will be copied to registers so accessing them will be extremely fast; for the second parameter we need to dereference a pointer and it will lead to memory read with a potential cache miss, so it&rsquo;s slower that the first parameter; the third parameter is the slowest one - to read from the vector we need to dereference it first and then dereference the element we want to access - that means two indirections.</p>
<p>Please notice that this is just a signature - it doesn&rsquo;t tell us what are the actual parameter values. Basically we can use as many different combinations of parameters as we can imagine with a single signature - the only mandatory is that we need to maintain correct types. Why did I tell all this? Because this is exactly how root signature works! We specify the input parameters and their types and later during runtime we call the function passing the actual data.</p>
<p>As you remember we have <code>4</code> resources for our demo - hull constant buffer, domain constant buffer and <code>2</code> domain structured buffers.</p>
<blockquote>
<p>&ldquo;But there&rsquo;re also vertex and index buffers&rdquo; - somebody can ask. Right, but they are <em>special</em> buffers - we need to create resources and corresponding views and pass this views directly to the pipeline in command list (as we&rsquo;ll see later). These views don&rsquo;t even need a resource heap!</p>
</blockquote>
<p>Also as we saw previously, the information about this resources should be stored in descriptors which should be stored in descriptor heaps. But I also mentioned that there&rsquo;re some other ways to pass data around. That&rsquo;s how we&rsquo;ll do it in our demo:</p>
<ol>
<li>
<p>Tesselation factors for the hull shader we&rsquo;ll pass <em>directly</em> in root signature. That means we don&rsquo;t need to create descriptor or descriptor heap or even resource itself! This works because we can pass <code>32bit</code> constants in root signature and they appear in shader as a constant buffer. Since we have only <code>2</code> tesselation factors this type of passing looks like a good choice. Moreover, this data will be accessed in a shader without indirection, just like <code>std::array&lt;int, 2&gt;</code> in an example c++ function signature!</p>
</li>
<li>
<p>For domain shader&rsquo;s constant buffer we will use a descriptor. But this decriptor will be passed as a part of the root signature. And that means we can bypass a descriptor heap. The descriptor will be inlined in the root signature - that&rsquo;s why we don&rsquo;t need to store it somewhere else. With root descriptor the shader first will read resource&rsquo;s address and than read the actual data. Just like <code>XMFLOAT4X4*</code> in an example c++ function signature!</p>
</li>
<li>
<p>For domain shader&rsquo;s structured buffers we will finaly use descriptor and descriptor heaps. That means we need to create a descriptor heap to hold <code>2</code> descriptors (one for every buffer) and desciptors itself. In order to pass information to the root signature we need to pack it to descriptor table. Descriptor table just tells which descriptor heap to use and the number of descriptors. When we need to access a buffer in a shader the runtime will first read the table, next will read the descriptor and finally will read the actual data. Just like <code>std::vector&lt;XMFLOAT3*&gt;*</code> in an example c++ function signature!</p>
</li>
</ol>
<blockquote>
<p>&ldquo;Why do we need to use descriptors or tables if we can pass everything as root constants?&rdquo; Root signature has a very limited size - <code>64DWORD</code> (<code>1DWORD</code> == <code>32bit</code>). That means we can store <code>64</code> ints inside it, or <code>4</code> matrices. If there&rsquo;s not enough place the data will be stored somewhere else and it will add one more level of indirection. Root descriptor asks for <code>2DWORD</code> and table only <code>1DWORD</code>.</p>
</blockquote>
<blockquote>
<p>Interesting note - <a href="https://developer.nvidia.com/dx12-dos-and-donts#roots">Nvidia</a> guys recommend to use root descriptors as much as you can. But <a href="http://gpuopen.com/performance-root-signature-descriptor-sets/">AMD</a> guys recommend to use tables.</p>
</blockquote>
<p>Remember that signature doesn&rsquo;t define any parameters - it just declares the type and the order. The actual data will be passed later.</p>
<p>Knowing all this we can write our first <code>directx 12</code> code.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12RootSignature<span style="color:#555">&gt;</span> rootSignature;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createRootSignature()
{
	<span style="color:#09f;font-style:italic">// #1
</span><span style="color:#09f;font-style:italic"></span>	D3D12_DESCRIPTOR_RANGE dsTransformAndColorSrvRange;
	ZeroMemory(<span style="color:#555">&amp;</span>dsTransformAndColorSrvRange, <span style="color:#069;font-weight:bold">sizeof</span>(dsTransformAndColorSrvRange));
	dsTransformAndColorSrvRange.RangeType <span style="color:#555">=</span> D3D12_DESCRIPTOR_RANGE_TYPE_SRV; <span style="color:#09f;font-style:italic">// we&#39;re using structured buffers - it&#39;s a SRV
</span><span style="color:#09f;font-style:italic"></span>	dsTransformAndColorSrvRange.NumDescriptors <span style="color:#555">=</span> <span style="color:#f60">2</span>; <span style="color:#09f;font-style:italic">// we have 2 structured buffers and 2 descriptors
</span><span style="color:#09f;font-style:italic"></span>	dsTransformAndColorSrvRange.BaseShaderRegister <span style="color:#555">=</span> <span style="color:#f60">0</span>; <span style="color:#09f;font-style:italic">// we start from the first register (t0)
</span><span style="color:#09f;font-style:italic"></span>	dsTransformAndColorSrvRange.RegisterSpace <span style="color:#555">=</span> <span style="color:#f60">0</span>; <span style="color:#09f;font-style:italic">// this allows us to use the same register name if we use different space
</span><span style="color:#09f;font-style:italic"></span>	dsTransformAndColorSrvRange.OffsetInDescriptorsFromTableStart <span style="color:#555">=</span> D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

	<span style="color:#09f;font-style:italic">// #2
</span><span style="color:#09f;font-style:italic"></span>	D3D12_ROOT_PARAMETER dsTransformAndColorSrv;
	ZeroMemory(<span style="color:#555">&amp;</span>dsTransformAndColorSrv, <span style="color:#069;font-weight:bold">sizeof</span>(dsTransformAndColorSrv));
	dsTransformAndColorSrv.ParameterType <span style="color:#555">=</span> D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	dsTransformAndColorSrv.DescriptorTable <span style="color:#555">=</span> { <span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>dsTransformAndColorSrvRange }; <span style="color:#09f;font-style:italic">// one range
</span><span style="color:#09f;font-style:italic"></span>	dsTransformAndColorSrv.ShaderVisibility <span style="color:#555">=</span> D3D12_SHADER_VISIBILITY_DOMAIN; <span style="color:#09f;font-style:italic">// only used in domain shader
</span><span style="color:#09f;font-style:italic"></span>
	<span style="color:#09f;font-style:italic">//#3
</span><span style="color:#09f;font-style:italic"></span>	D3D12_ROOT_PARAMETER dsObjCb;
	ZeroMemory(<span style="color:#555">&amp;</span>dsObjCb, <span style="color:#069;font-weight:bold">sizeof</span>(dsObjCb));
	dsObjCb.ParameterType <span style="color:#555">=</span> D3D12_ROOT_PARAMETER_TYPE_CBV; <span style="color:#09f;font-style:italic">// constant buffer
</span><span style="color:#09f;font-style:italic"></span>	dsObjCb.Descriptor <span style="color:#555">=</span> { <span style="color:#f60">0</span>, <span style="color:#f60">0</span> }; <span style="color:#09f;font-style:italic">// first register (b0) in first register space
</span><span style="color:#09f;font-style:italic"></span>	dsObjCb.ShaderVisibility <span style="color:#555">=</span> D3D12_SHADER_VISIBILITY_DOMAIN; <span style="color:#09f;font-style:italic">// only used in domain shader
</span><span style="color:#09f;font-style:italic"></span>
	<span style="color:#09f;font-style:italic">// #4
</span><span style="color:#09f;font-style:italic"></span>	D3D12_ROOT_PARAMETER hsTessFactorsCb;
	ZeroMemory(<span style="color:#555">&amp;</span>hsTessFactorsCb, <span style="color:#069;font-weight:bold">sizeof</span>(hsTessFactorsCb));
	hsTessFactorsCb.ParameterType <span style="color:#555">=</span> D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS;
	hsTessFactorsCb.Constants <span style="color:#555">=</span> { <span style="color:#f60">0</span>, <span style="color:#f60">0</span>, <span style="color:#f60">2</span> }; <span style="color:#09f;font-style:italic">// 2 constants in first register (b0) in first register space
</span><span style="color:#09f;font-style:italic"></span>	hsTessFactorsCb.ShaderVisibility <span style="color:#555">=</span> D3D12_SHADER_VISIBILITY_HULL; <span style="color:#09f;font-style:italic">// only used in hull shader
</span><span style="color:#09f;font-style:italic"></span>
	vector<span style="color:#555">&lt;</span>D3D12_ROOT_PARAMETER<span style="color:#555">&gt;</span> rootParameters{ dsObjCb, hsTessFactorsCb, dsTransformAndColorSrv };
	
	<span style="color:#09f;font-style:italic">// #5
</span><span style="color:#09f;font-style:italic"></span>	D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags{
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT <span style="color:#555">|</span> <span style="color:#09f;font-style:italic">// we&#39;re using vertex and index buffers
</span><span style="color:#09f;font-style:italic"></span>		D3D12_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS <span style="color:#555">|</span>
		D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS <span style="color:#555">|</span>
		D3D12_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS
	};

	<span style="color:#09f;font-style:italic">// #6
</span><span style="color:#09f;font-style:italic"></span>	D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>rootSignatureDesc, <span style="color:#069;font-weight:bold">sizeof</span>(rootSignatureDesc));
	rootSignatureDesc.NumParameters <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(rootParameters.size());
	rootSignatureDesc.pParameters <span style="color:#555">=</span> rootParameters.data();
	rootSignatureDesc.NumStaticSamplers <span style="color:#555">=</span> <span style="color:#f60">0</span>; <span style="color:#09f;font-style:italic">// samplers can be stored in root signature separately and consume no space
</span><span style="color:#09f;font-style:italic"></span>	rootSignatureDesc.pStaticSamplers <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">nullptr</span>; <span style="color:#09f;font-style:italic">// we&#39;re not using texturing
</span><span style="color:#09f;font-style:italic"></span>	rootSignatureDesc.Flags <span style="color:#555">=</span> rootSignatureFlags;

	<span style="color:#09f;font-style:italic">// #7
</span><span style="color:#09f;font-style:italic"></span>	ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> signature;
	ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> error;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3D12SerializeRootSignature(<span style="color:#555">&amp;</span>rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, signature.ReleaseAndGetAddressOf(), error.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error serializing root signature&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// finally create the root signature
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#09f;font-style:italic">// #8
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateRootSignature(<span style="color:#f60">0</span>, signature<span style="color:#555">-&gt;</span>GetBufferPointer(), signature<span style="color:#555">-&gt;</span>GetBufferSize(), IID_PPV_ARGS(rootSignature.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating root signature&#34;</span> });
	}
}</code></pre></div>
<p>We&rsquo;re using <code>3</code> root parameters: root descriptor for domain shader&rsquo;s constant buffer, <code>2</code> root constants for hull shader&rsquo;s constant buffer and a descriptor table for <code>2</code> structured buffers.</p>
<p>First we&rsquo;re creating a descriptor table - for this we need to specify the range of descriptors (<em>#1</em>) we&rsquo;ll use and pass this range to the parameter description (<em>#2</em>). Next we&rsquo;re creating a root descriptor for the domain constant buffer (<em>#3</em>). The final parameter is our root constants (<em>#4</em>). Notice how we specified shader visibility for each parameter. The api will validate this input and say us if there&rsquo;s something wrong. Also notice how we excluded certain stages from accessing root signature (<em>#5</em>) - this is recommended. Next we&rsquo;re creating root signature description struct (<em>#6</em>) with all the information we have so far and serializing it (<em>#7</em>). The last step is necessary because there&rsquo;s another way to create a root signature - directly in shader, not c++ app. And finally we&rsquo;re creating our root signature.</p>
<blockquote>
<p>Directx team kindly provided a helper header that simplifies creation of different structures - <code>d3dx12.h</code>. Thought the header is not a part of <code>directx 12</code> it&rsquo;s <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn708058(v=vs.85).aspx">well documented</a> in <code>msdn</code> and pretty solid. The <code>D3D12_DESCRIPTOR_RANGE</code> creation can be replaced with <code>CD3DX12_DESCRIPTOR_RANGE</code>, <code>D3D12_ROOT_PARAMETER</code> with <code>CD3DX12_ROOT_PARAMETER</code> and <code>D3D12_ROOT_SIGNATURE_DESC</code> with <code>CD3DX12_ROOT_SIGNATURE_DESC</code>. Using this helpers allow us to reduce and hence simplify code dramatically. I deliberatelly removed all <code>d3dx12.h</code> dependencies from my code just to show how api works under the hood.</p>
</blockquote>
<p>When we serialize the signature we can get errors which will be writtent to <code>error</code> instance. There&rsquo;re a lot of checks happens during serialization - for example if we&rsquo;ll overlap registers for the same shader (have two <code>b0</code>) we&rsquo;ll get an error. Very handy tool!</p>
<p>Now when we know about root signature we can update our diagram:</p>
<a href="#images%2fshader_res_2.png">
    <img src=images/shader_res_2.png class="thumbnail">
</a>
</br>
  

<a href="#_" class="lightbox" id="images/shader_res_2.png">
  <img src=images/shader_res_2.png>
</a>
<p>It&rsquo;s a little bit messy but if you&rsquo;ll follow arrows you&rsquo;ll see that it&rsquo;s the same as the code. Notice how hull shader constant buffer went away (because we&rsquo;re using inlined root constants) and descriptor heap for structured buffers appeared. There&rsquo;s still some mistery left, namely the size of the domain constant buffer (you&rsquo;ll learn about this later).</p>
<p>The last method - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899182(v=vs.85).aspx"><code>ID3D12Device::CreateRootSignature</code></a> - uses some <code>device</code> that we don&rsquo;t know yet. This is a software representation of the hardware and we&rsquo;ll find how to create one in the next section.</p>
<h4 id="directx-initialization">DirectX Initialization</h4>
<p>As you remember the base initialization is done in the base class called <code>Graphics</code>. This is how we create a device:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Device<span style="color:#555">&gt;</span> device;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createDevice()
{
	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3D12CreateDevice(adapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(<span style="color:#555">&amp;</span>device))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating device.&#34;</span> });
	}
}</code></pre></div>
<p>Simple enough. But what is this <code>adapter</code>? We can use <code>nullptr</code> instead and let the api to choose the default adapter, but let&rsquo;s see how we can select among many adapters that exist in our system. <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174523(v=vs.85).aspx"><code>IDXGIAdapter</code></a> is similar to <code>ID3D12Device</code> interface - it also a presentation of a gpu. It&rsquo;s hard for me to tell why do we need two similar interfaces that basically represent the same thing. Let&rsquo;s think that <code>dxgi</code> interface provides different information about a gpu itself (vendor, name etc.), but <code>d3d</code> interface allows us to manipulate it - create different resources, change states.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>IDXGIAdapter3<span style="color:#555">&gt;</span> adapter;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>getAdapter()
{
	ComPtr<span style="color:#555">&lt;</span>IDXGIAdapter1<span style="color:#555">&gt;</span> adapterTemp;

	<span style="color:#069;font-weight:bold">for</span> (UINT adapterIndex{ <span style="color:#f60">0</span> }; factory<span style="color:#555">-&gt;</span>EnumAdapters1(adapterIndex, adapterTemp.ReleaseAndGetAddressOf()) <span style="color:#555">!=</span> DXGI_ERROR_NOT_FOUND; <span style="color:#555">++</span>adapterIndex)
	{
		DXGI_ADAPTER_DESC1 desc;
		ZeroMemory(<span style="color:#555">&amp;</span>desc, <span style="color:#069;font-weight:bold">sizeof</span>(desc));

		adapterTemp<span style="color:#555">-&gt;</span>GetDesc1(<span style="color:#555">&amp;</span>desc);

		<span style="color:#069;font-weight:bold">if</span> (desc.Flags <span style="color:#555">&amp;</span> DXGI_ADAPTER_FLAG_SOFTWARE)
		{
			<span style="color:#069;font-weight:bold">continue</span>;
		}

		<span style="color:#069;font-weight:bold">if</span> (SUCCEEDED(adapterTemp.As(<span style="color:#555">&amp;</span>adapter)))
		{
			<span style="color:#069;font-weight:bold">break</span>;
		}
	}

	<span style="color:#069;font-weight:bold">if</span> (adapter <span style="color:#555">==</span> <span style="color:#069;font-weight:bold">nullptr</span>)
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error getting an adapter.&#34;</span> });
	}
}</code></pre></div>
<p>Here we just grab the first adapter that is not software (starting from <code>Windows 8</code> there&rsquo;s always a software adapter presented in the system). But you can use different logic - like checking a vendor. For enumerating we&rsquo;re using some <code>factory</code> which is <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174535(v=vs.85).aspx"><code>IDXGIFactory</code></a> interface. So let&rsquo;s create it too:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>IDXGIFactory4<span style="color:#555">&gt;</span> factory;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createFactory()
{
<span style="color:#099">#if defined(_DEBUG) 
</span><span style="color:#099"></span>	ComPtr<span style="color:#555">&lt;</span>ID3D12Debug<span style="color:#555">&gt;</span> debugController;
	<span style="color:#069;font-weight:bold">if</span> (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(<span style="color:#555">&amp;</span>debugController))))
	{
		debugController<span style="color:#555">-&gt;</span>EnableDebugLayer();
	}
<span style="color:#099">#endif
</span><span style="color:#099"></span>
	UINT factoryFlags{ <span style="color:#f60">0</span> };
<span style="color:#099">#if _DEBUG
</span><span style="color:#099"></span>	factoryFlags <span style="color:#555">=</span> DXGI_CREATE_FACTORY_DEBUG;
<span style="color:#099">#endif
</span><span style="color:#099"></span>
	<span style="color:#069;font-weight:bold">if</span> (FAILED(CreateDXGIFactory2(factoryFlags, IID_PPV_ARGS(factory.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating IDXGIFactory.&#34;</span> });
	}
}</code></pre></div>
<p>Finally no more new dependent interfaces! Thought there&rsquo;s one which we not depend on - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn950153(v=vs.85).aspx"><code>ID3D12Debug</code></a>. You should always use it with debug configuration. During an error it writes detailed message to the output.</p>
<p>Now we can compile the code we have successfully thought we&rsquo;ll not see anything on the screen. That&rsquo;s one of the downside of programming with directx - we can&rsquo;t have some intermediate results like render only one triangle from the teapot or shade only one pixel. We need to write a lot of code for both cpu and gpu just to find the black screen or artifacts.</p>
<p>At this point we have defined shaders and a signature. But the gpu doesn&rsquo;t know about our shaders - we only have several text files that are useful for us - not the hardware. As you have guessed we need to load our shaders to the graphics card. But first we need to compile them. Later we&rsquo;ll use a new addtition to the api which allows us to send this compiled data (and a lot of other stuff) to the gpu - pipeline state object (or pso for short).</p>
<h4 id="pipeline-state-object">Pipeline State Object</h4>
<p>As you know the gpu is a state machine - once it&rsquo;s setted up it will do the same actions over and over again until we change a state. In directx 12 the entire gpu state (plus or minus some minor things) is represented by <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788705(v=vs.85).aspx"><code>ID3D12PipelineState</code></a> interface. This means that if you want to render the same object in wireframe and solid you have to create <code>2</code> such objects which will differ only by fill mode. State creation is a heavy operation that should be avoided in runtime. Instead all states that you need for your scene should be created as a part of initialization.</p>
<p>In our demo we&rsquo;ll use <code>2</code> states - one for solid rendering and backface culling and another for wireframe rendering and without culling. Creating a state means filling a lot of structures and setting shaders. We&rsquo;re compiling our shaders as a build process in Visual Studio. This means that during application start we should have <code>cso</code> files somewhere which we need to load. The loading is very simple and can be done like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> vertexShaderBlob;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> hullShaderBlob;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> domainShaderBlob;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3DBlob<span style="color:#555">&gt;</span> pixelShaderBlob;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createShaders()
{
	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3DReadFileToBlob(<span style="color:#c30">L</span><span style="color:#c30">&#34;VertexShader.cso&#34;</span>, vertexShaderBlob.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error reading vertex shader.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3DReadFileToBlob(<span style="color:#c30">L</span><span style="color:#c30">&#34;HullShader.cso&#34;</span>, hullShaderBlob.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error reading hull shader.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3DReadFileToBlob(<span style="color:#c30">L</span><span style="color:#c30">&#34;DomainShader.cso&#34;</span>, domainShaderBlob.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error reading domain shader.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(D3DReadFileToBlob(<span style="color:#c30">L</span><span style="color:#c30">&#34;PixelShader.cso&#34;</span>, pixelShaderBlob.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error reading pixel shader.&#34;</span> });
	}
}</code></pre></div>
<p>And now the pipeline state creation (remember - we have <code>2</code> states):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12PipelineState<span style="color:#555">&gt;</span> pipelineStateWireframe;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12PipelineState<span style="color:#555">&gt;</span> pipelineStateSolid;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12PipelineState<span style="color:#555">&gt;</span> currPipelineState;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createPipelineStateWireframe()
{
	pipelineStateWireframe <span style="color:#555">=</span> createPipelineState(D3D12_FILL_MODE_WIREFRAME, D3D12_CULL_MODE_NONE);
	currPipelineState <span style="color:#555">=</span> pipelineStateWireframe;
}

<span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createPipelineStateSolid()
{
	pipelineStateSolid <span style="color:#555">=</span> createPipelineState(D3D12_FILL_MODE_SOLID, D3D12_CULL_MODE_NONE);
}

ComPtr<span style="color:#555">&lt;</span>ID3D12PipelineState<span style="color:#555">&gt;</span> TeapotTutorial<span style="color:#555">::</span>createPipelineState(D3D12_FILL_MODE fillMode, D3D12_CULL_MODE cullMode)
{
	<span style="color:#09f;font-style:italic">// #1
</span><span style="color:#09f;font-style:italic"></span>	vector<span style="color:#555">&lt;</span>D3D12_INPUT_ELEMENT_DESC<span style="color:#555">&gt;</span> inputElementDescs
	{
		{ <span style="color:#c30">&#34;POSITION&#34;</span>, <span style="color:#f60">0</span>, DXGI_FORMAT_R32G32B32_FLOAT, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, <span style="color:#f60">0</span> }
	};

	<span style="color:#09f;font-style:italic">// #2
</span><span style="color:#09f;font-style:italic"></span>	D3D12_RASTERIZER_DESC rasterizerDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>rasterizerDesc, <span style="color:#069;font-weight:bold">sizeof</span>(rasterizerDesc));
	rasterizerDesc.FillMode <span style="color:#555">=</span> fillMode;
	rasterizerDesc.CullMode <span style="color:#555">=</span> cullMode;
	rasterizerDesc.FrontCounterClockwise <span style="color:#555">=</span> FALSE;
	rasterizerDesc.DepthBias <span style="color:#555">=</span> D3D12_DEFAULT_DEPTH_BIAS;
	rasterizerDesc.DepthBiasClamp <span style="color:#555">=</span> D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
	rasterizerDesc.SlopeScaledDepthBias <span style="color:#555">=</span> D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
	rasterizerDesc.DepthClipEnable <span style="color:#555">=</span> TRUE;
	rasterizerDesc.MultisampleEnable <span style="color:#555">=</span> FALSE;
	rasterizerDesc.AntialiasedLineEnable <span style="color:#555">=</span> FALSE;
	rasterizerDesc.ForcedSampleCount <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	rasterizerDesc.ConservativeRaster <span style="color:#555">=</span> D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;

	<span style="color:#09f;font-style:italic">// #3
</span><span style="color:#09f;font-style:italic"></span>	D3D12_BLEND_DESC blendDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>blendDesc, <span style="color:#069;font-weight:bold">sizeof</span>(blendDesc));
	blendDesc.AlphaToCoverageEnable <span style="color:#555">=</span> FALSE;
	blendDesc.IndependentBlendEnable <span style="color:#555">=</span> FALSE;
	blendDesc.RenderTarget[<span style="color:#f60">0</span>] <span style="color:#555">=</span> {
		FALSE,FALSE,
		D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
		D3D12_BLEND_ONE, D3D12_BLEND_ZERO, D3D12_BLEND_OP_ADD,
		D3D12_LOGIC_OP_NOOP,
		D3D12_COLOR_WRITE_ENABLE_ALL
	};

	<span style="color:#09f;font-style:italic">// #4
</span><span style="color:#09f;font-style:italic"></span>	D3D12_DEPTH_STENCIL_DESC depthStencilDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>depthStencilDesc, <span style="color:#069;font-weight:bold">sizeof</span>(depthStencilDesc));
	depthStencilDesc.DepthEnable <span style="color:#555">=</span> TRUE;
	depthStencilDesc.DepthWriteMask <span style="color:#555">=</span> D3D12_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc <span style="color:#555">=</span> D3D12_COMPARISON_FUNC_LESS;
	depthStencilDesc.StencilEnable <span style="color:#555">=</span> FALSE;
	depthStencilDesc.StencilReadMask <span style="color:#555">=</span> D3D12_DEFAULT_STENCIL_READ_MASK;
	depthStencilDesc.StencilWriteMask <span style="color:#555">=</span> D3D12_DEFAULT_STENCIL_WRITE_MASK;
	<span style="color:#069;font-weight:bold">const</span> D3D12_DEPTH_STENCILOP_DESC defaultStencilOp <span style="color:#555">=</span> { D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_STENCIL_OP_KEEP, D3D12_COMPARISON_FUNC_ALWAYS };
	depthStencilDesc.FrontFace <span style="color:#555">=</span> defaultStencilOp;
	depthStencilDesc.BackFace <span style="color:#555">=</span> defaultStencilOp;

	<span style="color:#09f;font-style:italic">// #5
</span><span style="color:#09f;font-style:italic"></span>	D3D12_GRAPHICS_PIPELINE_STATE_DESC pipelineStateDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>pipelineStateDesc, <span style="color:#069;font-weight:bold">sizeof</span>(pipelineStateDesc));
	pipelineStateDesc.InputLayout <span style="color:#555">=</span> { inputElementDescs.data(), <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(inputElementDescs.size()) };
	pipelineStateDesc.pRootSignature <span style="color:#555">=</span> rootSignature.Get();
	pipelineStateDesc.VS <span style="color:#555">=</span> { vertexShaderBlob<span style="color:#555">-&gt;</span>GetBufferPointer(), vertexShaderBlob<span style="color:#555">-&gt;</span>GetBufferSize() };
	pipelineStateDesc.HS <span style="color:#555">=</span> { hullShaderBlob<span style="color:#555">-&gt;</span>GetBufferPointer(), hullShaderBlob<span style="color:#555">-&gt;</span>GetBufferSize() };
	pipelineStateDesc.DS <span style="color:#555">=</span> { domainShaderBlob<span style="color:#555">-&gt;</span>GetBufferPointer(), domainShaderBlob<span style="color:#555">-&gt;</span>GetBufferSize() };
	pipelineStateDesc.PS <span style="color:#555">=</span> { pixelShaderBlob<span style="color:#555">-&gt;</span>GetBufferPointer(), pixelShaderBlob<span style="color:#555">-&gt;</span>GetBufferSize() };
	pipelineStateDesc.RasterizerState <span style="color:#555">=</span> rasterizerDesc;
	pipelineStateDesc.BlendState <span style="color:#555">=</span> blendDesc;
	pipelineStateDesc.DepthStencilState <span style="color:#555">=</span> depthStencilDesc;
	pipelineStateDesc.SampleMask <span style="color:#555">=</span> UINT_MAX;
	pipelineStateDesc.PrimitiveTopologyType <span style="color:#555">=</span> D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH;
	pipelineStateDesc.NumRenderTargets <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	pipelineStateDesc.RTVFormats[<span style="color:#f60">0</span>] <span style="color:#555">=</span> DXGI_FORMAT_R8G8B8A8_UNORM;
	pipelineStateDesc.DSVFormat <span style="color:#555">=</span> DXGI_FORMAT_D32_FLOAT;
	pipelineStateDesc.SampleDesc.Count <span style="color:#555">=</span> <span style="color:#f60">1</span>;

	ComPtr<span style="color:#555">&lt;</span>ID3D12PipelineState<span style="color:#555">&gt;</span> pipelineState;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateGraphicsPipelineState(<span style="color:#555">&amp;</span>pipelineStateDesc, IID_PPV_ARGS(pipelineState.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating pipeline state.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">return</span> pipelineState;
}</code></pre></div>
<p>Wow, that&rsquo;s a lot of code. Let&rsquo;s step through the code line by line. First we create input layout (<em>#1</em>). In vertex shader we&rsquo;re expecting only one input - the control point position so we have only one entry in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn770377(v=vs.85).aspx"><code>D3D12_INPUT_ELEMENT_DESC</code></a> vector. Next we&rsquo;re creating a rasterizer state (<em>#2</em>). This structure can be replaced with a helper <code>CD3DX12_RASTERIZER_DESC</code> to make it shorter. Next is blend (<em>#</em>) - it can be replaced with <code>CD3DX12_BLEND_DESC</code>. Next is depth stencil (<em>#4</em> and <code>CD3DX12_DEPTH_STENCIL_DESC</code>). And finally pipeline state object itself where we assign all the things we created (<em>#5</em>). All these structures are pretty simple and I think it should be clear from the names what each field represent so I won&rsquo;t describe it in detail.</p>
<blockquote>
<p>Interesting thing - thought we assigned a root signature to pso this assignmend done only for validation, i.e. the api will check that shader inputs correspond to signature parameters. After pipeline state creation the information about root signature is lost and we need to assign it again before drawing.</p>
</blockquote>
<p>Yay, we have shaders, we have signature! But we still don&rsquo;t have resources. Let&rsquo;s fix that.</p>
<h4 id="creating-resources">Creating Resources</h4>
<p>Let&rsquo;s recall what resources do we need:</p>
<ul>
<li>Vertex Buffer</li>
<li>Index Buffer</li>
<li>Domain Constant Buffer</li>
<li>Transforms Structured Buffer</li>
<li>Colors Structured Buffer</li>
</ul>
<p>Before we start to create this buffers let&rsquo;s understand how gpu stores resources. Similar to descriptors resources are stored in a memory called resource heap. There&rsquo;re several types of heaps, but we&rsquo;ll use only two - <code>D3D12_HEAP_TYPE_DEFAULT</code> and <code>D3D12_HEAP_TYPE_UPLOAD</code>. The first one is entirely gpu resident - once you create it you can&rsquo;t access it on cpu side - even upload initial data. This heap type highly optimized and is faster than others. The second one is accessible by both gpu and cpu. We need a default heap when we have a static data - vertex and index buffers are good candidates. The upload heap is good when we change data every frame - for example a constant buffer. But if we can&rsquo;t write data to default buffer how can we use it? We can use some intermediate upload buffer, write data there from cpu and give a command to the gpu to copy the data from upload to default. I wrote &ldquo;give a command&rdquo; - yes, that&rsquo;t how we communicate with the gpu - we write predefined commands to some list and send this list to the graphic card where it executes.</p>
<p>All buffer instantiations are in constructor of our demo class.</p>
<p><strong>Vertex Buffer</strong></p>
<p>This is a special buffer that doesn&rsquo;t requires a descriptor heap (but still requires a descriptor/view).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> controlPointsBuffer;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span>controlPointsBuffer <span style="color:#555">=</span> teapot_tutorial<span style="color:#555">::</span>createVertexBuffer(device.Get(), TeapotData<span style="color:#555">::</span>points, <span style="color:#c30">L</span><span style="color:#c30">&#34;control points&#34;</span>);</code></pre></div>
<p>Looks simple, but it&rsquo;s not. Here we can see a helper function <code>teapot_tutorial::createVertexBuffer()</code> which takes a device (remember, we need it to create almost everything for the application), a data and a buffer name. The last parameter is super helpful during debugging - in visual studio graphics debugger we can easily find our buffer knowing it&rsquo;s name. This helper function lives in a helper header called <code>Utils.h</code> (surprise surprise) and this is how it&rsquo;s defined:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Utils.h
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">template</span><span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">typename</span> T<span style="color:#555">&gt;</span>
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> createVertexBuffer(ID3D12Device<span style="color:#555">*</span> device, <span style="color:#069;font-weight:bold">const</span> std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;&amp;</span> data, std<span style="color:#555">::</span>wstring name <span style="color:#555">=</span> <span style="color:#c30">L</span><span style="color:#c30">&#34;&#34;</span>)
{
	<span style="color:#069;font-weight:bold">return</span> details<span style="color:#555">::</span>createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, name);
}</code></pre></div>
<p>This function calls another helper function - <code>createDefaultBuffer()</code>;</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Utils.h
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">template</span><span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">typename</span> T<span style="color:#555">&gt;</span>
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> createDefaultBuffer(ID3D12Device<span style="color:#555">*</span> device, <span style="color:#069;font-weight:bold">const</span> std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;&amp;</span> data, D3D12_RESOURCE_STATES finalState, std<span style="color:#555">::</span>wstring name <span style="color:#555">=</span> <span style="color:#c30">L</span><span style="color:#c30">&#34;&#34;</span>)
{
	UINT elementSize{ <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(<span style="color:#069;font-weight:bold">sizeof</span>(T)) };
	UINT bufferSize{ <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(data.size() <span style="color:#555">*</span> elementSize) };
	
    <span style="color:#09f;font-style:italic">// #1
</span><span style="color:#09f;font-style:italic"></span>	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(<span style="color:#555">&amp;</span>heapProps, <span style="color:#069;font-weight:bold">sizeof</span>(heapProps));
	heapProps.Type <span style="color:#555">=</span> D3D12_HEAP_TYPE_DEFAULT;
	heapProps.CPUPageProperty <span style="color:#555">=</span> D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference <span style="color:#555">=</span> D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	heapProps.VisibleNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;

	<span style="color:#09f;font-style:italic">// #2
</span><span style="color:#09f;font-style:italic"></span>	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>resourceDesc, <span style="color:#069;font-weight:bold">sizeof</span>(resourceDesc));
	resourceDesc.Dimension <span style="color:#555">=</span> D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Alignment <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Width <span style="color:#555">=</span> bufferSize;
	resourceDesc.Height <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.DepthOrArraySize <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.MipLevels <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_UNKNOWN;
	resourceDesc.SampleDesc.Count <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.SampleDesc.Quality <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Layout <span style="color:#555">=</span> D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resourceDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_FLAG_NONE;

	<span style="color:#09f;font-style:italic">// #3
</span><span style="color:#09f;font-style:italic"></span>	Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> defaultBuffer;
	HRESULT hr{ device<span style="color:#555">-&gt;</span>CreateCommittedResource(
		<span style="color:#555">&amp;</span>heapProps,
		D3D12_HEAP_FLAG_NONE,
		<span style="color:#555">&amp;</span>resourceDesc,
		D3D12_RESOURCE_STATE_COPY_DEST,
		<span style="color:#069;font-weight:bold">nullptr</span>,
		IID_PPV_ARGS(defaultBuffer.ReleaseAndGetAddressOf())) };

	<span style="color:#069;font-weight:bold">if</span> (FAILED(hr))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a default buffer.&#34;</span> });
	}

	defaultBuffer<span style="color:#555">-&gt;</span>SetName(name.c_str());

	heapProps.Type <span style="color:#555">=</span> D3D12_HEAP_TYPE_UPLOAD;

	<span style="color:#09f;font-style:italic">// #4
</span><span style="color:#09f;font-style:italic"></span>	Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> uploadBuffer;
	hr <span style="color:#555">=</span> device<span style="color:#555">-&gt;</span>CreateCommittedResource(
		<span style="color:#555">&amp;</span>heapProps,
		D3D12_HEAP_FLAG_NONE,
		<span style="color:#555">&amp;</span>resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		<span style="color:#069;font-weight:bold">nullptr</span>,
		IID_PPV_ARGS(uploadBuffer.ReleaseAndGetAddressOf()));

	<span style="color:#069;font-weight:bold">if</span> (FAILED(hr))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating an upload buffer.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #5
</span><span style="color:#09f;font-style:italic"></span>	ComPtr<span style="color:#555">&lt;</span>ID3D12CommandAllocator<span style="color:#555">&gt;</span> commandAllocator;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(commandAllocator.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a command allocator.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #6
</span><span style="color:#09f;font-style:italic"></span>	Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12GraphicsCommandList<span style="color:#555">&gt;</span> commandList;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateCommandList(<span style="color:#f60">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), <span style="color:#069;font-weight:bold">nullptr</span>, IID_PPV_ARGS(commandList.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a command list.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #7
</span><span style="color:#09f;font-style:italic"></span>	D3D12_COMMAND_QUEUE_DESC queueDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>queueDesc, <span style="color:#069;font-weight:bold">sizeof</span>(queueDesc));
	queueDesc.Type <span style="color:#555">=</span> D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Priority <span style="color:#555">=</span> D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	queueDesc.Flags <span style="color:#555">=</span> D3D12_COMMAND_QUEUE_FLAG_NONE;
	queueDesc.NodeMask <span style="color:#555">=</span> <span style="color:#f60">0</span>;

	Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12CommandQueue<span style="color:#555">&gt;</span> commandQueue;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateCommandQueue(<span style="color:#555">&amp;</span>queueDesc, IID_PPV_ARGS(commandQueue.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a command queue.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #8
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#078;font-weight:bold">void</span><span style="color:#555">*</span> pData;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(uploadBuffer<span style="color:#555">-&gt;</span>Map(<span style="color:#f60">0</span>, <span style="color:#366">NULL</span>, <span style="color:#555">&amp;</span>pData)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed map intermediate resource.&#34;</span> });
	}

	memcpy(pData, data.data(), bufferSize);
	uploadBuffer<span style="color:#555">-&gt;</span>Unmap(<span style="color:#f60">0</span>, <span style="color:#366">NULL</span>);

	<span style="color:#09f;font-style:italic">// #9
</span><span style="color:#09f;font-style:italic"></span>	commandList<span style="color:#555">-&gt;</span>CopyBufferRegion(defaultBuffer.Get(), <span style="color:#f60">0</span>, uploadBuffer.Get(), <span style="color:#f60">0</span>, bufferSize);

	<span style="color:#09f;font-style:italic">// #10
</span><span style="color:#09f;font-style:italic"></span>	D3D12_RESOURCE_BARRIER barrierDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>barrierDesc, <span style="color:#069;font-weight:bold">sizeof</span>(barrierDesc));
	barrierDesc.Type <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrierDesc.Transition.pResource <span style="color:#555">=</span> defaultBuffer.Get();
	barrierDesc.Transition.StateBefore <span style="color:#555">=</span> D3D12_RESOURCE_STATE_COPY_DEST;
	barrierDesc.Transition.StateAfter <span style="color:#555">=</span> finalState;
	barrierDesc.Transition.Subresource <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	commandList<span style="color:#555">-&gt;</span>ResourceBarrier(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>barrierDesc);

	<span style="color:#09f;font-style:italic">// #11
</span><span style="color:#09f;font-style:italic"></span>	commandList<span style="color:#555">-&gt;</span>Close();
	std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>ID3D12CommandList<span style="color:#555">*&gt;</span> ppCommandLists{ commandList.Get() };
	commandQueue<span style="color:#555">-&gt;</span>ExecuteCommandLists(<span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(ppCommandLists.size()), ppCommandLists.data());

	<span style="color:#09f;font-style:italic">// #12
</span><span style="color:#09f;font-style:italic"></span>	UINT64 initialValue{ <span style="color:#f60">0</span> };
	Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Fence<span style="color:#555">&gt;</span> fence;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a fence.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #13
</span><span style="color:#09f;font-style:italic"></span>	HANDLE fenceEventHandle{ CreateEvent(<span style="color:#069;font-weight:bold">nullptr</span>, FALSE, FALSE, <span style="color:#069;font-weight:bold">nullptr</span>) };
	<span style="color:#069;font-weight:bold">if</span> (fenceEventHandle <span style="color:#555">==</span> <span style="color:#366">NULL</span>)
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating a fence event.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #14
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandQueue<span style="color:#555">-&gt;</span>Signal(fence.Get(), <span style="color:#f60">1</span>)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error siganalling buffer uploaded.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #15
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> (FAILED(fence<span style="color:#555">-&gt;</span>SetEventOnCompletion(<span style="color:#f60">1</span>, fenceEventHandle)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed set event on completion.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #16
</span><span style="color:#09f;font-style:italic"></span>	DWORD wait{ WaitForSingleObject(fenceEventHandle, <span style="color:#f60">10000</span>) };
	<span style="color:#069;font-weight:bold">if</span> (wait <span style="color:#555">!=</span> WAIT_OBJECT_0)
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed WaitForSingleObject().&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">return</span> defaultBuffer;
}</code></pre></div>
<p>Looks scary. But going step by step we&rsquo;ll get familar with a lot of directx 12 concepts. In the top we&rsquo;re creating a couple of structures that describe that we&rsquo;re going to create a default heap (<em>#1</em>) and a buffer (<em>#2</em>). Notice that we&rsquo;re not specifying the purpose of the buffer - we&rsquo;re just declaring the size. In other words we&rsquo;re asking for a certain amount of memory. Among other things notice that <code>Alignment</code> is <code>0</code>. Remember, on previous diagramm we had <code>2</code> numbers for the resource size - the actual data size and the alignement size. We should specify <code>64KB</code> for the buffer or <code>0</code> (which will set it to <code>64KB</code> under the hood). We can use helper structures <code>CD3DX12_HEAP_PROPERTIES</code> and <code>CD3DX12_RESOURCE_DESC</code> here.</p>
<p>Next we&rsquo;re calling <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899178(v=vs.85).aspx"><code>ID3D12Device::CreateCommittedResource()</code></a> method that actually reserves a memory (<em>#3</em>). This method asks the gpu to find a free space. There&rsquo;re other methods for resource creation - for example we can use already reserved memory and create placed resource in it - just like a <code>placement new</code> operator in c++ (we&rsquo;ll not use this in our demo).</p>
<p>Next we&rsquo;re creating an intermediate resource (<em>#4</em>). The only difference is that now we&rsquo;re asking for upload heap so we can write to it from the cpu.</p>
<p>Please note the <code>4th</code> parameter of ``ID3D12Device::CreateCommittedResource()<code>method. We used</code>D3D12_RESOURCE_STATE_COPY_DEST<code>for the default buffer and</code>D3D12_RESOURCE_STATE_GENERIC_READ<code>for upload. This are initial states of our resources. For the performance reasons gpu memory should be in some state when it's accessed. Upload buffer should be created with</code>D3D12_RESOURCE_STATE_GENERIC_READ<code>state. And in order to copy from the source to destination the destination should be in</code>D3D12_RESOURCE_STATE_COPY_DEST`.</p>
<p>Now it&rsquo;s time to make a step back and understand how cpu and gpu communicate with each other. Cpu tells gpu what to do via commands. There&rsquo;s a special interface <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903537%28v=vs.85%29.aspx"><code>ID3D12GraphicsCommandList</code></a> which have tons of methods and each method is an order to the gpu. Examples of such orders are <code>ClearDepthStencilView()</code> or <code>DrawInstanced()</code>. Command list is a cpu structure meaning that it knows nothing about gpu. The command list doesn&rsquo;t create anything. Instead it uses another special interface - <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn770463(v=vs.85).aspx"><code>ID3D12CommandAllocator</code></a> (<em>#5</em>). This object manages memory for commands and knows about gpu. This two interfaces work together - first we need to create an allocator and later tell command list to use this allocator for command memory allocation.</p>
<p>There&rsquo;re several types of command lists - copy, compute, bundle. We&rsquo;ll use <code>D3D12_COMMAND_LIST_TYPE_DIRECT</code> - this type can record commands of all mentioned types. As list and allocator tied together - they should have the same type.</p>
<p>When we create a list it is in a record state that means it&rsquo;s ready to receive commands (<em>#6</em>). There&rsquo;s also <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903895(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::Reset()</code></a> method which allow us to use command list with different allocator.</p>
<p>When we have a list filled with commands we need to tell gpu to do some work. We do this with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788627%28v=vs.85%29.aspx"><code>ID3D12CommandQueue</code></a> interface (<em>#7</em>). It should be the same type as our list and allocator.</p>
<p>Next we&rsquo;re mapping the system memory to the upload buffer (<em>#8</em>) and creating out first command with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903856(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::CopyBufferRegion()</code></a> (<em>#9</em>). It will tell the gpu to copy <code>bufferSize</code> amount of data from upload buffer (which actually points to the system memory) to default buffer.</p>
<p>After we finished with a resource update we need to transition default buffer to the state that will allow correct access to it. For different resources this state is different. For example for constant or vertex buffer it should be <code>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</code>, for structured buffer - <code>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</code>. So we creating a command that tells gpu to put a transition barrier to necessary state (<em>#10</em>). During this transition gpu will not touch the resource and will wait when transition is done. As you may guess this is an expensive operation. We can use helper structure <code>CD3DX12_RESOURCE_BARRIER</code> here.</p>
<p>Finally we&rsquo;re telling gpu to execute our commands with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788631(v=vs.85).aspx"><code>ID3D12CommandQueue::ExecuteCommandLists ()</code></a> method. But before we need to close command list or we&rsquo;ll get an error.</p>
<p>If we&rsquo;ll exit <code>createDefaultBuffer()</code> method now we&rsquo;ll get an undefined behavior. When we&rsquo;re telling the gpu to execute a list it doesn&rsquo;t start to do it immediately. Instead the commands are queued and nobody knows when they start or finish. That mean that if we leave now the upload buffer will be destroyed (we&rsquo;re not keeping a pointer to it) and when the gpu will be ready to execute a copy command the source will not be valid anymore.</p>
<p>Previously we talked about cpu-gpu communication. Now we&rsquo;re interested in gpu-cpu talk. We do it with fences. Fence is nothing more than an integer value. After we submitted a command list we can add one more command to the queue that will set the fence to the specified value. All we left to do is to check wherether our fence have a correct value or not and if it not - just wait untill it change. Super simple, isn&rsquo;t it? First we&rsquo;re creating <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899188%28v=vs.85%29.aspx"><code>ID3D12Fence</code></a> itself (<em>#12</em>) and also some <code>fenceEventHandle</code> (<em>#13</em>). This handle is not a part of <code>directx</code> but <code>winapi</code>. We&rsquo;re assigning value to the fence on the gpu with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899171(v=vs.85).aspx"><code>ID3D12CommandQueue::Signal()</code></a> method (<em>#14</em>). The first parameter is a fence object and the second is a desired value we want out fence be after the command list executed. Next we&rsquo;re setting an event on completion with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899190%28v=vs.85%29.aspx"><code>ID3D12Fence::SetEventOnCompletion()</code></a> method (<em>#15</em>). When the fence value will be equal to the first parameter then the event (second parameter) will be raised. In <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx"><code>WaitForSingleObject()</code></a> (<em>#16</em>) we&rsquo;re waiting when this happens for specified number of seconds (<code>10</code> seconds in our case but can be up to infinite). If at the moment of calling the fence already have a desired value it will return <code>WAIT_OBJECT_0</code> immediately in other case it will wait.</p>
<p>Finally we&rsquo;re returning created default buffer to the caller.</p>
<p>Now we need to create a view for our resource. Remember that resource is just a bunch of data in memory - we need to describe this data so the gpu can use it correctly.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>D3D12_VERTEX_BUFFER_VIEW controlPointsBufferView;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">using</span> PointType <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">decltype</span>(TeapotData<span style="color:#555">::</span>points)<span style="color:#555">::</span>value_type;

controlPointsBufferView.BufferLocation <span style="color:#555">=</span> controlPointsBuffer<span style="color:#555">-&gt;</span>GetGPUVirtualAddress();
controlPointsBufferView.StrideInBytes <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(<span style="color:#069;font-weight:bold">sizeof</span>(PointType));
controlPointsBufferView.SizeInBytes <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(controlPointsBufferView.StrideInBytes <span style="color:#555">*</span> TeapotData<span style="color:#555">::</span>points.size());</code></pre></div>
<p><strong>Index Buffer</strong></p>
<p>Similar to vertex buffer this buffer doesn’t require a descriptor heap.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> controlPointsIndexBuffer;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span>controlPointsIndexBuffer <span style="color:#555">=</span> teapot_tutorial<span style="color:#555">::</span>createIndexBuffer(device.Get(), TeapotData<span style="color:#555">::</span>patches, <span style="color:#c30">L</span><span style="color:#c30">&#34;patches&#34;</span>);</code></pre></div>
<p>And</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Utils.h
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">template</span><span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">typename</span> T<span style="color:#555">&gt;</span>
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> createIndexBuffer(ID3D12Device<span style="color:#555">*</span> device, <span style="color:#069;font-weight:bold">const</span> std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;&amp;</span> data, std<span style="color:#555">::</span>wstring name <span style="color:#555">=</span> <span style="color:#c30">L</span><span style="color:#c30">&#34;&#34;</span>)
{
	<span style="color:#069;font-weight:bold">return</span> details<span style="color:#555">::</span>createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_INDEX_BUFFER, name);
}</code></pre></div>
<p>Here we changed the final state of our buffer to <code>D3D12_RESOURCE_STATE_INDEX_BUFFER</code>. All other code remains the same as for the vertex buffer.</p>
<p>The view is also very simple:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>D3D12_INDEX_BUFFER_VIEW controlPointsIndexBufferView;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span>controlPointsIndexBufferView.BufferLocation <span style="color:#555">=</span> controlPointsIndexBuffer<span style="color:#555">-&gt;</span>GetGPUVirtualAddress();
controlPointsIndexBufferView.Format <span style="color:#555">=</span> DXGI_FORMAT_R32_UINT;
controlPointsIndexBufferView.SizeInBytes <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(TeapotData<span style="color:#555">::</span>patches.size() <span style="color:#555">*</span> <span style="color:#069;font-weight:bold">sizeof</span>(<span style="color:#078;font-weight:bold">uint32_t</span>));</code></pre></div>
<p><strong>Structured buffers</strong></p>
<p>Resource creation for this buffers is also the same as for previous buffers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> transformsBuffer;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> colorsBuffer;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span>transformsBuffer <span style="color:#555">=</span> teapot_tutorial<span style="color:#555">::</span>createStructuredBuffer(device.Get(), TeapotData<span style="color:#555">::</span>patchesTransforms, <span style="color:#c30">L</span><span style="color:#c30">&#34;transforms&#34;</span>);
colorsBuffer <span style="color:#555">=</span> teapot_tutorial<span style="color:#555">::</span>createStructuredBuffer(device.Get(), TeapotData<span style="color:#555">::</span>patchesColors, <span style="color:#c30">L</span><span style="color:#c30">&#34;colors&#34;</span>);</code></pre></div>
<p>Where <code>createStructuredBuffer</code> defined as here:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Utils.h
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">template</span><span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">typename</span> T<span style="color:#555">&gt;</span>
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> createStructuredBuffer(ID3D12Device<span style="color:#555">*</span> device, <span style="color:#069;font-weight:bold">const</span> std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>T<span style="color:#555">&gt;&amp;</span> data, std<span style="color:#555">::</span>wstring name <span style="color:#555">=</span> <span style="color:#c30">L</span><span style="color:#c30">&#34;&#34;</span>)
{
	<span style="color:#069;font-weight:bold">return</span> details<span style="color:#555">::</span>createDefaultBuffer(device, data, D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE, name);
}</code></pre></div>
<p>This buffer finally needs a descriptor heap which we&rsquo;re creating with the following code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12DescriptorHeap<span style="color:#555">&gt;</span> transformsAndColorsDescHeap;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createTransformsAndColorsDescHeap()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>heapDesc, <span style="color:#069;font-weight:bold">sizeof</span>(heapDesc));
	heapDesc.NumDescriptors <span style="color:#555">=</span> <span style="color:#f60">2</span>;
	heapDesc.Flags <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	heapDesc.Type <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	heapDesc.NodeMask <span style="color:#555">=</span> <span style="color:#f60">0</span>;

	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateDescriptorHeap(<span style="color:#555">&amp;</span>heapDesc, IID_PPV_ARGS(transformsAndColorsDescHeap.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating descriptor heap.&#34;</span> });
	}
}</code></pre></div>
<p>Here we&rsquo;re specifying that we need a heap for <code>2</code> descriptors. Remember - we have <code>2</code> structured buffers - transforms and colors. Next we&rsquo;re telling that we want this heap to be accessible from the shader. Examples of non shader visible heaps are render target view or stream output. Also we&rsquo;re defining a type. Constant buffer, srv and uav descriptors can leave in the same heap and this is for good - having many heaps and switching between them is not performance friendly.</p>
<p>Now when we have a heap we need to fill it with descriptors.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">using</span> TransformType <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">decltype</span>(TeapotData<span style="color:#555">::</span>patchesTransforms)<span style="color:#555">::</span>value_type;
<span style="color:#069;font-weight:bold">using</span> ColorType <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">decltype</span>(TeapotData<span style="color:#555">::</span>patchesColors)<span style="color:#555">::</span>value_type;
    
teapot_tutorial<span style="color:#555">::</span>createSrv<span style="color:#555">&lt;</span>TransformType<span style="color:#555">&gt;</span>(device.Get(), transformsAndColorsDescHeap.Get(), <span style="color:#f60">0</span>, transformsBuffer.Get(), TeapotData<span style="color:#555">::</span>patchesTransforms.size());
teapot_tutorial<span style="color:#555">::</span>createSrv<span style="color:#555">&lt;</span>ColorType<span style="color:#555">&gt;</span>(device.Get(), transformsAndColorsDescHeap.Get(), <span style="color:#f60">1</span>, colorsBuffer.Get(), TeapotData<span style="color:#555">::</span>patchesColors.size());</code></pre></div>
<p>Here we&rsquo;re calling a method from our <code>Utils.h</code> header:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Utils.h
</span><span style="color:#09f;font-style:italic"></span><span style="color:#069;font-weight:bold">template</span><span style="color:#555">&lt;</span><span style="color:#069;font-weight:bold">typename</span> T<span style="color:#555">&gt;</span>
<span style="color:#078;font-weight:bold">void</span> createSrv(ID3D12Device<span style="color:#555">*</span> device, ID3D12DescriptorHeap<span style="color:#555">*</span> descHeap, <span style="color:#078;font-weight:bold">int</span> offset, ID3D12Resource<span style="color:#555">*</span> resource, size_t numElements)
{
	<span style="color:#09f;font-style:italic">// #1
</span><span style="color:#09f;font-style:italic"></span>	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>srvDesc, <span style="color:#069;font-weight:bold">sizeof</span>(srvDesc));
	srvDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_UNKNOWN;
	srvDesc.ViewDimension <span style="color:#555">=</span> D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Shader4ComponentMapping <span style="color:#555">=</span> D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.FirstElement <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	srvDesc.Buffer.NumElements <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(numElements);
	srvDesc.Buffer.StructureByteStride <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(<span style="color:#069;font-weight:bold">sizeof</span>(T));
	srvDesc.Buffer.Flags <span style="color:#555">=</span> D3D12_BUFFER_SRV_FLAG_NONE;

	<span style="color:#09f;font-style:italic">// #2
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">static</span> UINT descriptorSize{ device<span style="color:#555">-&gt;</span>GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV) };
	D3D12_CPU_DESCRIPTOR_HANDLE d{ descHeap<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart() };
    <span style="color:#09f;font-style:italic">// #3
</span><span style="color:#09f;font-style:italic"></span>	d.ptr <span style="color:#555">+=</span> descriptorSize <span style="color:#555">*</span> offset;
    <span style="color:#09f;font-style:italic">// #4
</span><span style="color:#09f;font-style:italic"></span>	device<span style="color:#555">-&gt;</span>CreateShaderResourceView(resource, <span style="color:#555">&amp;</span>srvDesc, d);
}</code></pre></div>
<p>We&rsquo;re describing a view with the struct <code>D3D12_SHADER_RESOURCE_VIEW_DESC</code> (<em>#1</em>). Since we can have arbitrary stride in structured buffer the format should defined as <code>DXGI_FORMAT_UNKNOWN</code>. <code>Shader4ComponentMapping</code> is a bit confusing for me - it looks like we can force some components be <code>0</code> or <code>1</code>. We don&rsquo;t need this so we&rsquo;re using default mapping, but if you have information how this can be useful please write in comments. All other parameters are pretty strightforward.</p>
<p>Next we&rsquo;re creating descriptor in the heap. Descritors for constant buffer, srv and uav have the same size (but can differ in size among hardware vendors) and we&rsquo;re requesting this size with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn899186(v=vs.85).aspx"><code>ID3D12Device::GetDescriptorHandleIncrementSize()</code></a> method (<em>#2</em>). We&rsquo;re searching the place in the heap where we can create a descriptor (<em>#3</em>). The very first descriptor we can put in the heap start but for the next descriptor we need to offset position by the size of the descriptor. And finally we&rsquo;re asking the device to create specified descriptor in specified place (<em>#4</em>).</p>
<p><strong>Constant buffers</strong></p>
<p>The last resources left are constant buffers. If you refer back to theroot signature section you&rsquo;ll recal that we don&rsquo;t need resource and descriptor for tesselation factors for the hull shader since we&rsquo;re storing constants directly in the signature. So nothing to do here, moving on to the next buffer.</p>
<p>Constant buffer for domain shader stores a matrix. Recall that we store descriptor for this resource in the root signature so no need in descriptor heap. But we still need a resource itself. If you&rsquo;ll look at the diagram we drew before you&rsquo;ll notice that we still don&rsquo;t know the size of the buffer. Let&rsquo;s figure out why.</p>
<p>As you remember the commands are stored in the queue and don&rsquo;t execute immediately after submission. Cpu and gpu have different timelines. Now imagine that we submitted a matrix for frame <code>1</code> to constant buffer. Gpu is not executing yet. Now on cpu we&rsquo;re executing frame <code>2</code> and we need to update the matrix. If we&rsquo;ll write to the same place we did before the matrix from the frame <code>1</code> will be lost for the gpu. Or even worse - imagine that gpu starts reading the matrix at the moment we&rsquo;re updating it. How can we fix this? We can do exactly how we did when we created a default buffer. We can put a fence and stall the cpu until gpu finishes reading the matrix. As you understand this is not the way to go - when the cpu work gpu is idle and vice versa even if cpu and gpu can complete their tasks with the same speed. The solution is to have several buffers - in thi cace the cpu can update buffers safely. This is the same reason why we have several back buffers - we&rsquo;re displaying one while writing to another.</p>
<blockquote>
<p>Several buffers is not a silver buller. There still can be a situation when the cpu is faster than gpu and we need to syncronize anyway.</p>
</blockquote>
<p>So how much buffers do we need? Usually <code>2</code> or <code>3</code> is enough. In the demo I made this number adjustible but by default using <code>3</code>. That means that we need to create <code>3</code> constant buffers. Or create one big buffer that can fit <code>3</code> matrices (remember that resource is just a blob of memory). This is how we create our resource:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> constBuffer;

<span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>createConstantBuffer()
{
	UINT elementSizeAligned{ (<span style="color:#069;font-weight:bold">sizeof</span>(XMFLOAT4X4) <span style="color:#555">+</span> <span style="color:#f60">255</span>) <span style="color:#555">&amp;</span> <span style="color:#555">~</span><span style="color:#f60">255</span> };
	UINT64 bufferSize{ elementSizeAligned <span style="color:#555">*</span> bufferCount };

	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(<span style="color:#555">&amp;</span>heapProps, <span style="color:#069;font-weight:bold">sizeof</span>(heapProps));
	heapProps.Type <span style="color:#555">=</span> D3D12_HEAP_TYPE_UPLOAD;
	heapProps.CPUPageProperty <span style="color:#555">=</span> D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference <span style="color:#555">=</span> D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	heapProps.VisibleNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;

	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>resourceDesc, <span style="color:#069;font-weight:bold">sizeof</span>(resourceDesc));
	resourceDesc.Dimension <span style="color:#555">=</span> D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Alignment <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Width <span style="color:#555">=</span> bufferSize;
	resourceDesc.Height <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.DepthOrArraySize <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.MipLevels <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_UNKNOWN;
	resourceDesc.SampleDesc.Count <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.SampleDesc.Quality <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Layout <span style="color:#555">=</span> D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	resourceDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_FLAG_NONE;

	HRESULT hr{ device<span style="color:#555">-&gt;</span>CreateCommittedResource(
		<span style="color:#555">&amp;</span>heapProps,
		D3D12_HEAP_FLAG_NONE,
		<span style="color:#555">&amp;</span>resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		<span style="color:#069;font-weight:bold">nullptr</span>,
		IID_PPV_ARGS(constBuffer.ReleaseAndGetAddressOf())
	) };

	<span style="color:#069;font-weight:bold">if</span> (FAILED(hr))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating constant buffer.&#34;</span> });
	}

	constBuffer<span style="color:#555">-&gt;</span>SetName(<span style="color:#c30">L</span><span style="color:#c30">&#34;constants&#34;</span>);
}</code></pre></div>
<p>Since constant buffer will be updated every frame there&rsquo;s no need to create it with default type. The read of constant buffer in directx 12 should be aligned by <code>256B</code>. If we have <code>4x4</code> matrix of <code>float</code> which requires <code>16 * 4 = 64B</code> we can&rsquo;t place the next matrix immediately after it or we&rsquo;ll break the alignment rule and will get an error. So our total size for <code>3</code> buffers will be <code>3 * 256 = 768B</code>. And since constant buffer is just a usual buffer it will be aligned by <code>64KB</code>. Finally we can finish our diagram.</p>
<a href="#images%2fshader_res_3.png">
    <img src=images/shader_res_3.png class="thumbnail">
</a>
</br>
  

<a href="#_" class="lightbox" id="images/shader_res_3.png">
  <img src=images/shader_res_3.png>
</a>
<blockquote>
<p>The weird looking line <code>(sizeof(XMFLOAT4X4) + 255) &amp; ~255</code> calculates the next multiple of <code>256</code>.</p>
</blockquote>
<p>One more time, since this is very important - in our case we have <code>1</code> buffer which can hold <code>3</code> matrices. In every frame we can safely update corresponding matrix. Let&rsquo;s call this frames <em>buffered frames</em>. But if we have all <code>3</code> frames in flight (i.e. gpu not finished to render any of them yet) we can&rsquo;t update out buffer and we have to wait.</p>
<p>At this point we have shaders, device and resources but we&rsquo;re still not ready to draw. We don&rsquo;t have a buffer to draw, a swap chain to present a back buffer and some other things.</p>
<h4 id="directx-initialization-part-2">DirectX Initialization part 2</h4>
<p>You already know what are command lists, command allocator, fences - we used them when we created our resources. We need the same resources for rendering - after all rendering is just commands to the gpu what to do.</p>
<blockquote>
<p>We could create one command list, allocator, fence for entire application and reuse it for rendering, resource creation but I decided to use more functional approach and for simplicity created an isolated function for resource creation.</p>
</blockquote>
<p>Remember when we discussed matrix constant buffer we decided to use multiple buffers to avoid stalls and you know that we should use several resources for buffered frames (we&rsquo;re using <code>3</code> frames by default but this number can be changed). So for rendering we need to use <code>3</code> command allocators, <code>3</code> fences but only one command list. This is because when we&rsquo;re resetting a list it can be reused immediately - the memory for commands managed by the allocator. So we can reuse the same list with several allocators.</p>
<blockquote>
<p>If we would use multiple threads for commands creation submission, we have to use <code>3 * numTheads</code> allocators and <code>numThreads</code> lists. That&rsquo;s because when the list is in use with particular allocator it can&rsquo;t be used with another until it closed.</p>
</blockquote>
<p>This is how we&rsquo;re creating necessary data:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12CommandAllocator<span style="color:#555">&gt;&gt;</span> commandAllocators;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12GraphicsCommandList<span style="color:#555">&gt;</span> commandList;
std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Fence<span style="color:#555">&gt;&gt;</span> fences;
std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>UINT64<span style="color:#555">&gt;</span> fenceValues;
HANDLE fenceEventHandle;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createCommandAllocators()
{
	<span style="color:#069;font-weight:bold">for</span> (UINT i{ <span style="color:#f60">0</span> }; i <span style="color:#555">&lt;</span> bufferCount; i<span style="color:#555">++</span>)
	{
		ComPtr<span style="color:#555">&lt;</span>ID3D12CommandAllocator<span style="color:#555">&gt;</span> commandAllocator;
		<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(commandAllocator.ReleaseAndGetAddressOf()))))
		{
			<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating command allocator.&#34;</span> });
		}

		commandAllocators.push_back(commandAllocator);
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createCommandList()
{
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateCommandList(<span style="color:#f60">0</span>, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocators[<span style="color:#f60">0</span>].Get(), <span style="color:#069;font-weight:bold">nullptr</span>, IID_PPV_ARGS(commandList.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating command list.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandList<span style="color:#555">-&gt;</span>Close()))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error closing command list.&#34;</span> });
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createFences()
{
	<span style="color:#069;font-weight:bold">for</span> (UINT i{ <span style="color:#f60">0</span> }; i <span style="color:#555">&lt;</span> bufferCount; i<span style="color:#555">++</span>)
	{
		UINT64 initialValue{ <span style="color:#f60">0</span> };
		ComPtr<span style="color:#555">&lt;</span>ID3D12Fence<span style="color:#555">&gt;</span> fence;
		<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateFence(initialValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.ReleaseAndGetAddressOf()))))
		{
			<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating fence.&#34;</span> });
		}

		fences.push_back(fence);
		fenceValues.push_back(initialValue);
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createFenceEventHandle()
{
	fenceEventHandle <span style="color:#555">=</span> CreateEvent(<span style="color:#069;font-weight:bold">nullptr</span>, FALSE, FALSE, <span style="color:#069;font-weight:bold">nullptr</span>);
	<span style="color:#069;font-weight:bold">if</span> (fenceEventHandle <span style="color:#555">==</span> <span style="color:#366">NULL</span>)
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating fence event.&#34;</span> });
	}
}</code></pre></div>
<p>All this code should be already familar to you. Here we&rsquo;re creating allocators, a list and we&rsquo;re closing it because we&rsquo;re not going to use it now, fences - one for each buffered frame and one handle. We need multiple fences by the same reason we need multiple allocators. Imagine we submitted commands for frame <code>1</code> and told the queue to set a fence after this frame. We do the same for frames <code>2</code> and <code>3</code>. Now when we&rsquo;re ready to reuse allocator <code>1</code> we need to check fence value <code>1</code> - not <code>2</code> or <code>3</code> (they still can be in use) and if the value is what we&rsquo;re expecting we can safely reuse the memory. In other case we need to wait.</p>
<p>Next we&rsquo;ll create command queue and  swap chain:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12CommandQueue<span style="color:#555">&gt;</span> commandQueue;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>IDXGISwapChain3<span style="color:#555">&gt;</span> swapChain;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createCommandQueue()
{
	D3D12_COMMAND_QUEUE_DESC queueDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>queueDesc, <span style="color:#069;font-weight:bold">sizeof</span>(queueDesc));
	queueDesc.Type <span style="color:#555">=</span> D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Priority <span style="color:#555">=</span> D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	queueDesc.Flags <span style="color:#555">=</span> D3D12_COMMAND_QUEUE_FLAG_NONE;
	queueDesc.NodeMask <span style="color:#555">=</span> <span style="color:#f60">0</span>;

	HRESULT hr{ device<span style="color:#555">-&gt;</span>CreateCommandQueue(<span style="color:#555">&amp;</span>queueDesc, IID_PPV_ARGS(commandQueue.ReleaseAndGetAddressOf())) };
	<span style="color:#069;font-weight:bold">if</span> (FAILED(hr))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating command queue.&#34;</span> });
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createSwapChain()
{
	POINT <span style="color:#c0f">wSize</span>(window<span style="color:#555">-&gt;</span>getSize());

	DXGI_SWAP_CHAIN_DESC1 swapChainDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>swapChainDesc, <span style="color:#069;font-weight:bold">sizeof</span>(swapChainDesc));
	swapChainDesc.Width <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(wSize.x);
	swapChainDesc.Height <span style="color:#555">=</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(wSize.y);
	swapChainDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_R8G8B8A8_UNORM;
	swapChainDesc.Stereo <span style="color:#555">=</span> FALSE;
	swapChainDesc.SampleDesc <span style="color:#555">=</span> { <span style="color:#f60">1</span>, <span style="color:#f60">0</span> }; <span style="color:#09f;font-style:italic">// no anti-aliasing
</span><span style="color:#09f;font-style:italic"></span>	swapChainDesc.BufferUsage <span style="color:#555">=</span> DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.BufferCount <span style="color:#555">=</span> bufferCount;
	swapChainDesc.Scaling <span style="color:#555">=</span> DXGI_SCALING_NONE;
	swapChainDesc.SwapEffect <span style="color:#555">=</span> DXGI_SWAP_EFFECT_FLIP_DISCARD;
	swapChainDesc.Flags <span style="color:#555">=</span> <span style="color:#f60">0</span>;

	ComPtr<span style="color:#555">&lt;</span>IDXGISwapChain1<span style="color:#555">&gt;</span> swapChain1;
	<span style="color:#069;font-weight:bold">if</span> (FAILED(factory<span style="color:#555">-&gt;</span>CreateSwapChainForHwnd(commandQueue.Get(), window<span style="color:#555">-&gt;</span>getHandle(), <span style="color:#555">&amp;</span>swapChainDesc, <span style="color:#069;font-weight:bold">nullptr</span>, <span style="color:#069;font-weight:bold">nullptr</span>, swapChain1.ReleaseAndGetAddressOf())))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating IDXGISwapChain1.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(swapChain1.As(<span style="color:#555">&amp;</span>swapChain)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating IDXGISwapChain3.&#34;</span> });
	}
}</code></pre></div>
<p>You should be familar with command queue. The swap chain concept didn&rsquo;t change since directx 11 the only interesting thing is that you need to specify command queue during swap chain creation. Here <code>bufferCount</code> variable is a number of buffered frames.</p>
<p>Now it&rsquo;s time to create back buffers:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>std<span style="color:#555">::</span>vector<span style="color:#555">&lt;</span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;&gt;</span> swapChainBuffers;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12DescriptorHeap<span style="color:#555">&gt;</span> descHeapRtv;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>getSwapChainBuffers()
{
	<span style="color:#069;font-weight:bold">for</span> (UINT i{ <span style="color:#f60">0</span> }; i <span style="color:#555">&lt;</span> bufferCount; i<span style="color:#555">++</span>)
	{
		<span style="color:#069;font-weight:bold">if</span> (FAILED(swapChain<span style="color:#555">-&gt;</span>GetBuffer(i, IID_PPV_ARGS(swapChainBuffers[i].ReleaseAndGetAddressOf()))))
		{
			<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error getting buffer.&#34;</span> });
		}
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createDescriptoprHeapRtv()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>heapDesc, <span style="color:#069;font-weight:bold">sizeof</span>(heapDesc));
	heapDesc.Type <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	heapDesc.NumDescriptors <span style="color:#555">=</span> bufferCount;
	heapDesc.NodeMask <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	heapDesc.Flags <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_FLAG_NONE;

	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateDescriptorHeap(<span style="color:#555">&amp;</span>heapDesc, IID_PPV_ARGS(descHeapRtv.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating descriptor heap.&#34;</span> });
	}

	UINT rtvStep{ device<span style="color:#555">-&gt;</span>GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV) };
	<span style="color:#069;font-weight:bold">for</span> (UINT i{ <span style="color:#f60">0</span> }; i <span style="color:#555">&lt;</span> bufferCount; i<span style="color:#555">++</span>)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE d <span style="color:#555">=</span> descHeapRtv<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart();
		d.ptr <span style="color:#555">+=</span> i <span style="color:#555">*</span> rtvStep;
		device<span style="color:#555">-&gt;</span>CreateRenderTargetView(swapChainBuffers[i].Get(), <span style="color:#069;font-weight:bold">nullptr</span>, d);
	}
}</code></pre></div>
<p>When we specified the number of back buffers in swap chain creation they become created implicitly so we don&rsquo;t need to create resources manualy. But we still need to create descriptors for all our back buffers. In <code>Graphics::getSwapChainBuffers()</code> we&rsquo;re obtaining pointers to created resources and in <code>Graphics::createDescriptoprHeapRtv()</code> we&rsquo;re creating a descriptor heap (recal that descriptors should be stored somewhere) with the type <code>D3D12_DESCRIPTOR_HEAP_TYPE_RTV</code> and big enough to store necessary amount of views. Next we&rsquo;re iterating over obtained buffer pointers and for every resource we&rsquo;re creating a corresponding view (recal that <code>ID3D12Device::GetDescriptorHandleIncrementSize</code> is a cross vendor way to get descriptor size).</p>
<p>For our demo we also need a depth buffer:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.h
</span><span style="color:#09f;font-style:italic"></span>Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12Resource<span style="color:#555">&gt;</span> depthStencilBuffer;
Microsoft<span style="color:#555">::</span>WRL<span style="color:#555">::</span>ComPtr<span style="color:#555">&lt;</span>ID3D12DescriptorHeap<span style="color:#555">&gt;</span> descHeapDepthStencil;

<span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createDepthStencilBuffer()
{
	D3D12_CLEAR_VALUE depthOptimizedClearValue;
	ZeroMemory(<span style="color:#555">&amp;</span>depthOptimizedClearValue, <span style="color:#069;font-weight:bold">sizeof</span>(depthOptimizedClearValue));
	depthOptimizedClearValue.Format <span style="color:#555">=</span> DXGI_FORMAT_D32_FLOAT;
	depthOptimizedClearValue.DepthStencil.Depth <span style="color:#555">=</span> <span style="color:#f60">1.0f</span>;
	depthOptimizedClearValue.DepthStencil.Stencil <span style="color:#555">=</span> <span style="color:#f60">0</span>;

	POINT <span style="color:#c0f">wSize</span>(window<span style="color:#555">-&gt;</span>getSize());

	D3D12_HEAP_PROPERTIES heapProps;
	ZeroMemory(<span style="color:#555">&amp;</span>heapProps, <span style="color:#069;font-weight:bold">sizeof</span>(heapProps));
	heapProps.Type <span style="color:#555">=</span> D3D12_HEAP_TYPE_DEFAULT;
	heapProps.CPUPageProperty <span style="color:#555">=</span> D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
	heapProps.MemoryPoolPreference <span style="color:#555">=</span> D3D12_MEMORY_POOL_UNKNOWN;
	heapProps.CreationNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	heapProps.VisibleNodeMask <span style="color:#555">=</span> <span style="color:#f60">1</span>;

	D3D12_RESOURCE_DESC resourceDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>resourceDesc, <span style="color:#069;font-weight:bold">sizeof</span>(resourceDesc));
	resourceDesc.Dimension <span style="color:#555">=</span> D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	resourceDesc.Alignment <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Width <span style="color:#555">=</span> wSize.x;
	resourceDesc.Height <span style="color:#555">=</span> wSize.y;
	resourceDesc.DepthOrArraySize <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.MipLevels <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_D32_FLOAT;
	resourceDesc.SampleDesc.Count <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	resourceDesc.SampleDesc.Quality <span style="color:#555">=</span> <span style="color:#f60">0</span>;
	resourceDesc.Layout <span style="color:#555">=</span> D3D12_TEXTURE_LAYOUT_UNKNOWN;
	resourceDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

	HRESULT hr{ device<span style="color:#555">-&gt;</span>CreateCommittedResource(
		<span style="color:#555">&amp;</span>heapProps,
		D3D12_HEAP_FLAG_NONE,
		<span style="color:#555">&amp;</span>resourceDesc,
		D3D12_RESOURCE_STATE_DEPTH_WRITE,
		<span style="color:#555">&amp;</span>depthOptimizedClearValue,
		IID_PPV_ARGS(depthStencilBuffer.ReleaseAndGetAddressOf())
	) };

	<span style="color:#069;font-weight:bold">if</span> (FAILED(hr))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating depth stencil buffer.&#34;</span> });
	}
}

<span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>createDescriptorHeapDepthStencil()
{
	D3D12_DESCRIPTOR_HEAP_DESC heapDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>heapDesc, <span style="color:#069;font-weight:bold">sizeof</span>(heapDesc));
	heapDesc.NumDescriptors <span style="color:#555">=</span> <span style="color:#f60">1</span>;
	heapDesc.Type <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	heapDesc.Flags <span style="color:#555">=</span> D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	
	<span style="color:#069;font-weight:bold">if</span> (FAILED(device<span style="color:#555">-&gt;</span>CreateDescriptorHeap(<span style="color:#555">&amp;</span>heapDesc, IID_PPV_ARGS(descHeapDepthStencil.ReleaseAndGetAddressOf()))))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error creating depth stencil descriptor heap.&#34;</span> });
	}

	D3D12_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>depthStencilViewDesc, <span style="color:#069;font-weight:bold">sizeof</span>(depthStencilViewDesc));
	depthStencilViewDesc.Format <span style="color:#555">=</span> DXGI_FORMAT_D32_FLOAT;
	depthStencilViewDesc.ViewDimension <span style="color:#555">=</span> D3D12_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Flags <span style="color:#555">=</span> D3D12_DSV_FLAG_NONE;

	device<span style="color:#555">-&gt;</span>CreateDepthStencilView(depthStencilBuffer.Get(), <span style="color:#555">&amp;</span>depthStencilViewDesc, descHeapDepthStencil<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart());
}</code></pre></div>
<p>Nothing special here - we&rsquo;re creating a resource heap with default type (depth buffer used by gpu without cpu access) and a texture resource. Field names are self explanatory - dimension, size, etc. In flags we&rsquo;re specifying that we want to use this texture as depth stencil. And as we did million times already we`re creating a descriptor heap and a descriptor inside it.</p>
<p>Wow. Finally. We&rsquo;re ready to draw!</p>
<h4 id="rendering">Rendering</h4>
<p>We have everything for our demo - all resources and infrastructure. Now we&rsquo;ll call <code>TeapotTutorial::render()</code> method every frame where we&rsquo;ll tell gpu to use resources and run shaders.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// TeapotTutorial.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> TeapotTutorial<span style="color:#555">::</span>render()
{
	<span style="color:#09f;font-style:italic">// #1
</span><span style="color:#09f;font-style:italic"></span>	UINT frameIndex{ swapChain<span style="color:#555">-&gt;</span>GetCurrentBackBufferIndex() }; 

	<span style="color:#09f;font-style:italic">// #2
</span><span style="color:#09f;font-style:italic"></span>	ComPtr<span style="color:#555">&lt;</span>ID3D12CommandAllocator<span style="color:#555">&gt;</span> commandAllocator{ commandAllocators[frameIndex] }; 

	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandAllocator<span style="color:#555">-&gt;</span>Reset()))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error resetting command allocator.&#34;</span> });
	}

	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandList<span style="color:#555">-&gt;</span>Reset(commandAllocator.Get(), <span style="color:#069;font-weight:bold">nullptr</span>)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Error resetting command list.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #3
</span><span style="color:#09f;font-style:italic"></span>	commandList<span style="color:#555">-&gt;</span>SetPipelineState(currPipelineState.Get());
	commandList<span style="color:#555">-&gt;</span>SetGraphicsRootSignature(rootSignature.Get());
	commandList<span style="color:#555">-&gt;</span>RSSetViewports(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>viewport);
	commandList<span style="color:#555">-&gt;</span>RSSetScissorRects(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>scissorRect);

	<span style="color:#09f;font-style:italic">// #4
</span><span style="color:#09f;font-style:italic"></span>	ID3D12Resource<span style="color:#555">*</span> currBuffer{ swapChainBuffers[frameIndex].Get() };

	<span style="color:#09f;font-style:italic">// #5
</span><span style="color:#09f;font-style:italic"></span>	D3D12_RESOURCE_BARRIER barrierDesc;
	ZeroMemory(<span style="color:#555">&amp;</span>barrierDesc, <span style="color:#069;font-weight:bold">sizeof</span>(barrierDesc));
	barrierDesc.Type <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Transition.pResource <span style="color:#555">=</span> currBuffer;
	barrierDesc.Transition.Subresource <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrierDesc.Transition.StateBefore <span style="color:#555">=</span> D3D12_RESOURCE_STATE_PRESENT;
	barrierDesc.Transition.StateAfter <span style="color:#555">=</span> D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_FLAG_NONE;
	commandList<span style="color:#555">-&gt;</span>ResourceBarrier(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>barrierDesc);

	<span style="color:#09f;font-style:italic">// #6
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">static</span> UINT descriptorSize{ device<span style="color:#555">-&gt;</span>GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV) };
	D3D12_CPU_DESCRIPTOR_HANDLE <span style="color:#c0f">descHandleRtv</span>(descHeapRtv<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart());
	descHandleRtv.ptr <span style="color:#555">+=</span> frameIndex <span style="color:#555">*</span> descriptorSize;

	D3D12_CPU_DESCRIPTOR_HANDLE <span style="color:#c0f">descHandleDepthStencil</span>(descHeapDepthStencil<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart());

	commandList<span style="color:#555">-&gt;</span>OMSetRenderTargets(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>descHandleRtv, FALSE, <span style="color:#555">&amp;</span>descHandleDepthStencil);

	<span style="color:#09f;font-style:italic">// #7
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">static</span> <span style="color:#078;font-weight:bold">float</span> clearColor[]{ <span style="color:#f60">0.1f</span>, <span style="color:#f60">0.1f</span>, <span style="color:#f60">0.1f</span>, <span style="color:#f60">1.0f</span> };
	commandList<span style="color:#555">-&gt;</span>ClearRenderTargetView(descHandleRtv, clearColor, <span style="color:#f60">0</span>, <span style="color:#069;font-weight:bold">nullptr</span>);
	commandList<span style="color:#555">-&gt;</span>ClearDepthStencilView(descHeapDepthStencil<span style="color:#555">-&gt;</span>GetCPUDescriptorHandleForHeapStart(), D3D12_CLEAR_FLAG_DEPTH, <span style="color:#f60">1.0f</span>, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>, <span style="color:#069;font-weight:bold">nullptr</span>);
	commandList<span style="color:#555">-&gt;</span>IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST);

	<span style="color:#09f;font-style:italic">// #8
</span><span style="color:#09f;font-style:italic"></span>	vector<span style="color:#555">&lt;</span>D3D12_VERTEX_BUFFER_VIEW<span style="color:#555">&gt;</span> myArray{ controlPointsBufferView };
	commandList<span style="color:#555">-&gt;</span>IASetVertexBuffers(<span style="color:#f60">0</span>, <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(myArray.size()), myArray.data());

	<span style="color:#09f;font-style:italic">// #9
</span><span style="color:#09f;font-style:italic"></span>	vector<span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">int</span><span style="color:#555">&gt;</span> rootConstants{ tessFactor, tessFactor };
	commandList<span style="color:#555">-&gt;</span>SetGraphicsRoot32BitConstants(<span style="color:#f60">1</span>, <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span>UINT<span style="color:#555">&gt;</span>(rootConstants.size()), rootConstants.data(), <span style="color:#f60">0</span>);

	<span style="color:#09f;font-style:italic">// #10
</span><span style="color:#09f;font-style:italic"></span>	ID3D12DescriptorHeap<span style="color:#555">*</span> ppHeaps[] <span style="color:#555">=</span> { transformsAndColorsDescHeap.Get() };
	commandList<span style="color:#555">-&gt;</span>SetDescriptorHeaps(<span style="color:#f60">1</span>, ppHeaps);
	D3D12_GPU_DESCRIPTOR_HANDLE d { transformsAndColorsDescHeap<span style="color:#555">-&gt;</span>GetGPUDescriptorHandleForHeapStart() };
	d.ptr <span style="color:#555">+=</span> <span style="color:#f60">0</span>;
	commandList<span style="color:#555">-&gt;</span>SetGraphicsRootDescriptorTable(<span style="color:#f60">2</span>, d);

	<span style="color:#09f;font-style:italic">// #11
</span><span style="color:#09f;font-style:italic"></span>	POINT <span style="color:#c0f">windowSize</span>(window<span style="color:#555">-&gt;</span>getSize());
	<span style="color:#078;font-weight:bold">float</span> ratio{ <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.x) <span style="color:#555">/</span> <span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.y) };
	XMMATRIX projMatrixDX{ XMMatrixPerspectiveFovLH(XMConvertToRadians(<span style="color:#f60">45</span>), ratio, <span style="color:#f60">1.0f</span>, <span style="color:#f60">100.0f</span>) };

	XMVECTOR <span style="color:#c0f">camPositionDX</span>(XMVectorSet(<span style="color:#f60">0.0f</span>, <span style="color:#f60">0.0f</span>, <span style="color:#555">-</span><span style="color:#f60">10.0f</span>, <span style="color:#f60">0.0f</span>));
	XMVECTOR <span style="color:#c0f">camLookAtDX</span>(XMVectorSet(<span style="color:#f60">0.0f</span>, <span style="color:#f60">0.0f</span>, <span style="color:#f60">0.0f</span>, <span style="color:#f60">0.0f</span>));
	XMVECTOR <span style="color:#c0f">camUpDX</span>(XMVectorSet(<span style="color:#f60">0.0f</span>, <span style="color:#f60">1.0f</span>, <span style="color:#f60">0.0f</span>, <span style="color:#f60">0.0f</span>));
	XMMATRIX viewMatrixDX{ XMMatrixLookAtLH(camPositionDX, camLookAtDX, camUpDX) };

	XMMATRIX viewProjMatrixDX{ viewMatrixDX <span style="color:#555">*</span> projMatrixDX };
	UINT constDataSizeAligned{ (<span style="color:#069;font-weight:bold">sizeof</span>(XMFLOAT4X4) <span style="color:#555">+</span> <span style="color:#f60">255</span>) <span style="color:#555">&amp;</span> <span style="color:#555">~</span><span style="color:#f60">255</span> };

	POINT <span style="color:#c0f">mousePoint</span>(window<span style="color:#555">-&gt;</span>getMousePosition());
	<span style="color:#078;font-weight:bold">float</span> pitch{ <span style="color:#555">-</span>XMConvertToRadians((mousePoint.x <span style="color:#555">-</span> (<span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.x) <span style="color:#555">/</span> <span style="color:#f60">2.0f</span>)) <span style="color:#555">/</span> (<span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.x) <span style="color:#555">/</span> <span style="color:#f60">2.0f</span>) <span style="color:#555">*</span> <span style="color:#f60">180.0f</span>) };
	<span style="color:#078;font-weight:bold">float</span> roll{ XMConvertToRadians((mousePoint.y <span style="color:#555">-</span> (<span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.y) <span style="color:#555">/</span> <span style="color:#f60">2.0f</span>)) <span style="color:#555">/</span> (<span style="color:#069;font-weight:bold">static_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">float</span><span style="color:#555">&gt;</span>(windowSize.y) <span style="color:#555">/</span> <span style="color:#f60">2.0f</span>) <span style="color:#555">*</span> <span style="color:#f60">180.0f</span>) };

	XMMATRIX modelMatrixRotationDX{ XMMatrixRotationRollPitchYaw(roll, pitch, <span style="color:#f60">0.0f</span>) };
	XMMATRIX modelMatrixTranslationDX{ XMMatrixTranslation(<span style="color:#f60">0.0f</span>, <span style="color:#555">-</span><span style="color:#f60">1.0f</span>, <span style="color:#f60">0.0f</span>) };
	XMMATRIX modelMatrixDX{ modelMatrixRotationDX <span style="color:#555">*</span> modelMatrixTranslationDX };
	XMFLOAT4X4 mvpMatrix;
	XMStoreFloat4x4(<span style="color:#555">&amp;</span>mvpMatrix, modelMatrixDX <span style="color:#555">*</span> viewProjMatrixDX);

	<span style="color:#09f;font-style:italic">// #12
</span><span style="color:#09f;font-style:italic"></span>	D3D12_RANGE readRange <span style="color:#555">=</span> {<span style="color:#f60">0</span>, <span style="color:#f60">0</span>};
	<span style="color:#078;font-weight:bold">uint8_t</span><span style="color:#555">*</span> cbvDataBegin;
	constBuffer<span style="color:#555">-&gt;</span>Map(<span style="color:#f60">0</span>, <span style="color:#555">&amp;</span>readRange, <span style="color:#069;font-weight:bold">reinterpret_cast</span><span style="color:#555">&lt;</span><span style="color:#078;font-weight:bold">void</span><span style="color:#555">**&gt;</span>(<span style="color:#555">&amp;</span>cbvDataBegin));
	memcpy(<span style="color:#555">&amp;</span>cbvDataBegin[frameIndex <span style="color:#555">*</span> constDataSizeAligned], <span style="color:#555">&amp;</span>mvpMatrix, <span style="color:#069;font-weight:bold">sizeof</span>(mvpMatrix));
	constBuffer<span style="color:#555">-&gt;</span>Unmap(<span style="color:#f60">0</span>, <span style="color:#069;font-weight:bold">nullptr</span>);

	<span style="color:#09f;font-style:italic">// #13
</span><span style="color:#09f;font-style:italic"></span>	commandList<span style="color:#555">-&gt;</span>SetGraphicsRootConstantBufferView(<span style="color:#f60">0</span>, constBuffer<span style="color:#555">-&gt;</span>GetGPUVirtualAddress() <span style="color:#555">+</span> frameIndex <span style="color:#555">*</span> constDataSizeAligned);

	<span style="color:#09f;font-style:italic">// #14
</span><span style="color:#09f;font-style:italic"></span>	commandList<span style="color:#555">-&gt;</span>IASetIndexBuffer(<span style="color:#555">&amp;</span>controlPointsIndexBufferView);

	<span style="color:#09f;font-style:italic">// #15
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#078;font-weight:bold">uint32_t</span> numIndices{ controlPointsIndexBufferView.SizeInBytes <span style="color:#555">/</span> <span style="color:#069;font-weight:bold">sizeof</span>(<span style="color:#078;font-weight:bold">uint32_t</span>) };
	commandList<span style="color:#555">-&gt;</span>DrawIndexedInstanced(numIndices, <span style="color:#f60">1</span>, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>, <span style="color:#f60">0</span>);

	<span style="color:#09f;font-style:italic">// #16
</span><span style="color:#09f;font-style:italic"></span>	ZeroMemory(<span style="color:#555">&amp;</span>barrierDesc, <span style="color:#069;font-weight:bold">sizeof</span>(barrierDesc));
	barrierDesc.Type <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierDesc.Transition.pResource <span style="color:#555">=</span> currBuffer;
	barrierDesc.Transition.Subresource <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrierDesc.Transition.StateBefore <span style="color:#555">=</span> D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierDesc.Transition.StateAfter <span style="color:#555">=</span> D3D12_RESOURCE_STATE_PRESENT;
	barrierDesc.Flags <span style="color:#555">=</span> D3D12_RESOURCE_BARRIER_FLAG_NONE;
	commandList<span style="color:#555">-&gt;</span>ResourceBarrier(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>barrierDesc);

	<span style="color:#09f;font-style:italic">// #17
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandList<span style="color:#555">-&gt;</span>Close()))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed closing command list.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #18
</span><span style="color:#09f;font-style:italic"></span>	ID3D12CommandList<span style="color:#555">*</span> cmdList{ commandList.Get() };
	commandQueue<span style="color:#555">-&gt;</span>ExecuteCommandLists(<span style="color:#f60">1</span>, <span style="color:#555">&amp;</span>cmdList);

	<span style="color:#09f;font-style:italic">// #19
</span><span style="color:#09f;font-style:italic"></span>	<span style="color:#069;font-weight:bold">if</span> (FAILED(swapChain<span style="color:#555">-&gt;</span>Present(<span style="color:#f60">1</span>, <span style="color:#f60">0</span>)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed present.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #20
</span><span style="color:#09f;font-style:italic"></span>	UINT64<span style="color:#555">&amp;</span> fenceValue{ fenceValues[frameIndex] };
	<span style="color:#555">++</span>fenceValue;
	ComPtr<span style="color:#555">&lt;</span>ID3D12Fence<span style="color:#555">&gt;</span> fence{ fences[frameIndex] };
	<span style="color:#069;font-weight:bold">if</span> (FAILED(commandQueue<span style="color:#555">-&gt;</span>Signal(fence.Get(), fenceValue)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed signal.&#34;</span> });
	}

	<span style="color:#09f;font-style:italic">// #21
</span><span style="color:#09f;font-style:italic"></span>	waitFrameComplete(swapChain<span style="color:#555">-&gt;</span>GetCurrentBackBufferIndex());
}</code></pre></div>
<p>As usual we&rsquo;ll go step by step.</p>
<p><code>IDXGISwapChain3</code> have a very handy method <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903675(v=vs.85).aspx">IDXGISwapChain3::GetCurrentBackBufferIndex()</a> (<em>#1</em>). It shows the index of the current back buffer. In the beginnig the index is <code>0</code> and after calling <code>IDXGISwapChain::Present()</code> it will change to <code>2</code> (if we have more than <code>1</code> buffer of course). So we don&rsquo;t need to track manually the current frame.</p>
<p>Using current frame index we can obtain a corresponding allocator (<em>#2</em>). We need to reset it before we can start to work with it. Remember that we need to be sure that there&rsquo;re no more commands in flight from this allocator so we&rsquo;ll not break anything. Also we need to tell our command list that we&rsquo;re going to use this allocator with it.</p>
<p>Next we&rsquo;re setting pso, signature, viewport and scissor rect (<em>#3</em>). We didn&rsquo;t discuss the last two objects. They&rsquo;re pretty strightforward and created with other resources in constructor (please refer to <a href="https://github.com/nikitablack/directx-12/blob/master/TeapotTutorial/TeapotTutorial/TeapotTutorial.cpp">github</a>).</p>
<p>Also we need to get a pointer to the current back buffer (<em>#4</em>) since we&rsquo;ll use it several times.</p>
<p>Now when we have a back buffer we need to move it to the correct state. Since we&rsquo;re going to render a teapot into it the state should be <code>D3D12_RESOURCE_STATE_RENDER_TARGET</code> (<em>#5</em>).</p>
<p>Next we need to say gpu that we want to use this back buffer as a render target. But we can&rsquo;t do it directly. Instead we need to set the view that describes this buffer. As you know all views are stored in descriptor heap. All we need to do is to calculate the correct offset from the heap start (<em>#6</em>). And we&rsquo;re doing the same for the depth buffer (we have only one depth buffer so the descriptor and heap have same addreses).</p>
<p>Next we&rsquo;re clearing render target and depth buffer to some initial values and also specifying the topology we&rsquo;re going to use in this draw - <code>D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST</code> (<em>#7</em>).</p>
<p>Next we need to specify a vertex buffer. Again, we&rsquo;re doing it with a view (<em>#8</em>).</p>
<p>Do you remember how we created our root signature? The second parameter were <code>2</code> root constants for the hull shader. We&rsquo;re using single <code>tessFactor</code> constant for both edge and inside factors and we&rsquo;re setting this constant with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903910(v=vs.85).aspx"><code>ID3D12GraphicsCommandList::SetGraphicsRoot32BitConstants()</code></a> method specifying the position in the root signature (<em>#9</em>).</p>
<p>Third parameter in the root signature was a descriptor table. Recall that the table points to a continious range of descriptors in descriptor heap. During parameter creation we specified that we&rsquo;ll use <code>2</code> descriptors. All we have to do is to pass an address of the first descriptor in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn903912(v=vs.85).aspx"><code>ID3D12GraphicsCommandList-&gt;SetGraphicsRootDescriptorTable()</code></a> method (<em>#10</em>). But before we need to set a correct descriptor heap or we&rsquo;ll get an error.</p>
<p>Next we&rsquo;re doing some math (<em>#11</em>) - creating a projection matrix, view matrix, rotating our model depending on mouse position. And updating our upload constant buffer with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dn788712%28v=vs.85%29.aspx"><code>ID3D12Resource-&gt;Map()</code></a> method (<em>#12</em>). As you remember our constant buffer store data for all our buffered frames. In order to write to the correct place we need to use a correct offset from the start of the buffer (don&rsquo;t forget about <code>256B</code> alignment).</p>
<p>Now when we have updated constant buffer we&rsquo;re ready to finish with the root signature. We&rsquo;re setting the last parameter - root descriptor as a first parameter not forgetting the correct offset from descriptor heap start (<em>#13</em>).</p>
<p>Next we&rsquo;re setting index buffer via view (<em>#14</em>) and drawing (<em>#15</em>).</p>
<p>If you&rsquo;re thinking that after drawing we can relax - I&rsquo;ll upset you. We still need some work to do. Remember that before drawing to a back buffer we set it&rsquo;s state as <code>D3D12_RESOURCE_STATE_RENDER_TARGET</code>. In order to be presented the buffer have to be in <code>D3D12_RESOURCE_STATE_PRESENT</code> state (<em>#16</em>).</p>
<p>Now when we&rsquo;re done with command list we need to close it (<em>#17</em>) and send it to the command queue for execution (<em>#18</em>).</p>
<p>After calling <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb174576(v=vs.85).aspx"><code>IDXGISwapChain-&gt;Present()</code></a> (<em>#19</em>) we need to tell the gpu to increment corresponding fence after frame will finish (<em>#20</em>). Exactly how we did during default buffer creation. For example if we rendered a frame <code>0</code> we need to update a fence <code>0</code> for this frame and store the updated value (also with index <code>0</code>) on cpu. This way we can anytime check the current value of fence <code>0</code> and say for sure if it&rsquo;s done or not. And we&rsquo;re doing it in <code>waitFrameComplete()</code> function (<em>#21</em>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span><span style="color:#078;font-weight:bold">void</span> Graphics<span style="color:#555">::</span>waitFrameComplete(UINT frameIndex)
{
	UINT64 fenceValue{ fenceValues[frameIndex] };
	ComPtr<span style="color:#555">&lt;</span>ID3D12Fence<span style="color:#555">&gt;</span> fence{ fences[frameIndex] };

	<span style="color:#069;font-weight:bold">if</span> (FAILED(fence<span style="color:#555">-&gt;</span>SetEventOnCompletion(fenceValue, fenceEventHandle)))
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed set event on completion.&#34;</span> });
	}

	DWORD wait{ WaitForSingleObject(fenceEventHandle, <span style="color:#f60">10000</span>) };
	<span style="color:#069;font-weight:bold">if</span> (wait <span style="color:#555">!=</span> WAIT_OBJECT_0)
	{
		<span style="color:#069;font-weight:bold">throw</span>(runtime_error{ <span style="color:#c30">&#34;Failed WaitForSingleObject().&#34;</span> });
	}
}</code></pre></div>
<p>One more time - imagine we just finished a frame with index <code>2</code>. Since we have <code>3</code> buffered frames total the next index will be <code>0</code>. In <code>waitFrameComplete()</code> we&rsquo;re checking the status of frame <code>0</code> - if it&rsquo;s still in flight we have to stall and wait until fence will be equal to the expected value.</p>
<h4 id="cleanup">Cleanup</h4>
<p>One thing we didn&rsquo;t mention is cleaning. But it&rsquo;s pretty simple - since we used smart pointers we don&rsquo;t need to delete pointers manually. The only thing we need to take care of is to be sure that during resources desctruction gpu finished with them. We can do it with good old fences:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#09f;font-style:italic">// Graphics.cpp
</span><span style="color:#09f;font-style:italic"></span>Graphics<span style="color:#555">::~</span>Graphics()
{
	<span style="color:#069;font-weight:bold">for</span> (UINT i{ <span style="color:#f60">0</span> }; i <span style="color:#555">&lt;</span> bufferCount; i<span style="color:#555">++</span>)
	{
		waitFrameComplete(i);
	}
}</code></pre></div>
<p>Here I just iterate over all buffered frames and check that all they are done.</p>
<h4 id="conclusion">Conclusion</h4>
<p>Wow, that&rsquo;s was a really long journey. As you can see there&rsquo;s a lot of code for such a simple application but most of this code can be abstracted with reusable structures like ones in <code>d3dx12.h</code>.</p>
<p>What we did today is just scratched a surface - directx12 api is very complex and still evolving. But I encourage you to continue investigation - after all it&rsquo;s so fun :)</p>
<p>The video below shows the result of work we done. And <a href="https://github.com/nikitablack/directx-12/tree/master/TeapotTutorial/TeapotTutorial">here</a> is the full source.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/m5Lac8TNsc0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>
      
      <div class="related">
</div>
      
    </div>
    
  </div>
</section>



<section class="section">
  <div class="container has-text-centered">
    <p>If you like what I do you can <a href="https://www.buymeacoffee.com/nikitablack">buy me a coffee</a> &copy; <a href="http://nikitablack.github.io/">nikitablack</a> 2021</p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/ribice/kiss">Kiss</a>.</p>
    
  </div>
</section>



</body>
</html>

