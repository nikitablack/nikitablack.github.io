= Vulkan by example - Shaders
:hp-tags: c++, vulkan, glsl

In the https://TODO[previous lesson] I made all preparations necessary to start exploring vulkan. Here is the diagramm of the current state of the application:

[picture]

The diagramm is pretty empty now but it will grow as I progress through tutorials. For now it's enough to know that there's a CPU, which controls the application and orchestrates the GPU; a GPU itself, which do magic and produces nice pictures (not necessarily); a window which should show these pictures.

Now the logic question - what's next? I will start from the heart of every graphics application - by my opinion it is shaders, after all this is exactly what GPU runs. In my program I will use 4 shader stages - Vertex, Tesselation Control, Tesselation Eveluation, Fragment. Next I will step over all of these stages briefly explaining the purpose of each.

===== Vertex shader

This is the first stage in the pipeline and it's pretty simple. Looking back to the teapot data I know which information which needs to be passed - since I'm using patches I need to provide points describing them - `16` points for every patch.

----
#version 450

layout(location = 0) in vec3 inPosition;

out gl_PerVertex
{
    vec4 gl_Position;
};

void main()
{
    gl_Position = vec4(inPosition, 1.0);
}
----

A patch point arrives to the shader at location `0` and simply gets passed to the next stage. Thi stage will be executed for every point (vertex) that is provided. Since I use `28` patches `16` point each it will be called at least `28 * 16 = 448` times (it's not an important information - just for fun).

===== Tessellation control shader

----
#version 450

layout(push_constant) uniform TessLevel
{
	float value;
} tessLevel;

layout(vertices = 16) out;

void main()
{
    if (gl_InvocationID == 0)
    {
        gl_TessLevelInner[0] = tessLevel.value;
        gl_TessLevelInner[1] = tessLevel.value;

        gl_TessLevelOuter[0] = tessLevel.value;
        gl_TessLevelOuter[1] = tessLevel.value;
        gl_TessLevelOuter[2] = tessLevel.value;
        gl_TessLevelOuter[3] = tessLevel.value;
    }

    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}
----

This shader simple as well as it doesn't do a lot of work, but it have a couple of interesting moments. The first one is how I update a tesselation level (how many details a tesselator should create). I decided to use the so called `Push Constant` - a feature that allows to pass a constant directly in command buffer. Don't affraid of all these terms right now - I'll explain what all this means when I reach the actual code that uses them. For now it's enough to know that the tesselation level is a float variable (to make a subdivision more smooth) that somehow updates from a CPU. Next I tell the GPU that this stage produces 16 control points for the patch, i.e. doesn't change the amount (yes, this stage can generate new points as well as remove some).

===== Tessellation Evaluation shader

This shader is the actual workhorse of the whole application - all the magic happens here.

----
#version 450

layout (quads, fractional_odd_spacing, cw) in;

struct PatchData
{
	mat4 transform;
	vec4 color;
};

layout(binding = 0, row_major) buffer PatchDataBuffer
{
	PatchData data[];
} patchData;

layout(binding = 1) uniform Proj
{
	layout(row_major) mat4 mat;
} proj;

layout(binding = 2) uniform View
{
	layout(row_major) mat4 mat;
} view;

layout(binding = 3) uniform Model
{
	layout(row_major) mat4 mat;
} model;

layout (location = 0) out vec3 outColor;

vec4 bernsteinBasis(float t)
{
	float invT = 1.0f - t;

	return vec4(invT * invT * invT, // (1-t)^3
	            3.0f * t * invT * invT, // 3t(1-t)^2
	            3.0f * t * t * invT, // 3t2(1-t)
	            t * t * t); // t3
}

vec4 evaluateBezier(vec4 basisU, vec4 basisV)
{
	vec4 value = vec4(0.0, 0.0, 0.0, 0.0);

	value = basisV.x * (gl_in[0].gl_Position * basisU.x + gl_in[1].gl_Position * basisU.y + gl_in[2].gl_Position * basisU.z + gl_in[3].gl_Position * basisU.w);
	value += basisV.y * (gl_in[4].gl_Position * basisU.x + gl_in[5].gl_Position * basisU.y + gl_in[6].gl_Position * basisU.z + gl_in[7].gl_Position * basisU.w);
	value += basisV.z * (gl_in[8].gl_Position * basisU.x + gl_in[9].gl_Position * basisU.y + gl_in[10].gl_Position * basisU.z + gl_in[11].gl_Position * basisU.w);
	value += basisV.w * (gl_in[12].gl_Position * basisU.x + gl_in[13].gl_Position * basisU.y + gl_in[14].gl_Position * basisU.z + gl_in[15].gl_Position * basisU.w);
	value.w = 1.0;

	return value;
}

void main(void)
{
	vec4 basisU = bernsteinBasis(gl_TessCoord.x);
	vec4 basisV = bernsteinBasis(gl_TessCoord.y);

	vec4 localPos = evaluateBezier(basisU, basisV);

	gl_Position = localPos * patchData.data[gl_PrimitiveID].transform * model.mat * view.mat * proj.mat;

	outColor = patchData.data[gl_PrimitiveID].color.xyz;
}
----

First I need to specify tesselation rules: domain (`quad`), spacing (`fractional_odd_spacing`) and winding order (`cw` - clockwise). Next I define the patch information in the form of a buffer. Again, no information right now - just know that each patch should be transformed and colored (see https://TODO[introduction lesson] for more details why) and the information incoming as an array of `PatchData`. Also I need usual transformation matrices. I could provide one MVP-matrix and reduce the number of calculations but I want to show how to manipulate with multiple uniform buffers in `Vulkan`. That's why there are three matrices: model, view and projection.

Next is a scary math - calculation of a 3d point having a `gl_TessCoord` that came from tesselator. Actually the math is not that complicated, a found https://www.gamasutra.com/view/feature/131755/curved_surfaces_using_bzier_.php[this gamasutra article] very good at explaining the theory behind curves.And the code itself (functions `bernsteinBasis()` and `evaluateBezier()`) I shamelesly took from http://www.gdcvault.com/play/1012740/direct3d[this gdc presentation].

The outputs of this shader are newly generated vertex and color. Since the entire patch colored with a solid color every vertex from one patch will have the same attribute.

I think it's obvious that this shader will be invoked as many times as the number of generated vertices.

===== Fragment shader

----
#version 450

layout(location = 0) out vec4 outColor;

layout(location = 0) in vec3 fragColor;

void main()
{
    outColor = vec4(fragColor, 1.0);
}
----

Another one _"lazy"_ shader - the data is coming at input location `0` and going to the output storage location also `0`. Latter tells that there's should be some special memory region (`Image` in that case) somewhere.

Hurray! The application is almost done! Joking. Once I read the sentense which describes `Vulkan` in a nutshell: _"Show me your triangle in three months."_ The same applies here - I'm planning to write `7` or `8` parts total. Shaders were the easiest part, all other code serves only to make them run and run *correctly*. By correctness I mean that there should not be undefined behavior, data races, pipeline stalls.

===== Finally some Vulkan

So I have some shaders written as text in some files, but I can't use them directly. In `Vulkan` shaders have to be compiled to so called `SPIR-V` binary format and supplied to the API via https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkShaderModule.html[`VkShaderModule`]. I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateShaderModule.html[`vkCreateShaderModule`] function. Here's the definition of this function:

----
VkResult vkCreateShaderModule(
    VkDevice                                    device,
    const VkShaderModuleCreateInfo*             pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkShaderModule*                             pShaderModule);
----

Last parameter (`pShaderModule`) is a return value I'm interesting in. Third parameter (`pAllocator`) used for custom allocation and *never* will be used in lessons (always `nullptr`). Second parameter (`pCreateInfo`) is an information which describes a shader and can be created right now. But the first parameter (`device`) is an unknown variable.

https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkDevice.html[`VkDevice`] is a software representation of `GPU`. I think about it like an instance of a real physical `GPU` - it is possible to have multiple instances of it (though I will use only one). I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateDevice.html[`vkCreateDevice`] function:

----
VkResult vkCreateDevice(
    VkPhysicalDevice                            physicalDevice,
    const VkDeviceCreateInfo*                   pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDevice*                                   pDevice);
----

`pDevice` - return value, `pAllocator` - `nullptr`, `pCreateInfo` - some information, `physicalDevice` - again unknown.

Continuing the analogy https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDevice.html[`VkPhysicalDevice`] is a class or a blueprint. It represents unique piece of hardware and can be used for obtaining some useful info, like capabilities of the `GPU`. I can't create an instance of it, but can ask the API to give it with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkEnumeratePhysicalDevices.html[`vkEnumeratePhysicalDevices`] call:

----
VkResult vkEnumeratePhysicalDevices(
    VkInstance                                  instance,
    uint32_t*                                   pPhysicalDeviceCount,
    VkPhysicalDevice*                           pPhysicalDevices);
----

It will never end... Here again I see an unknown variable `instance`. Moreover, this function can return a list of *all* available devices in the system but I'm interested only in one. For the application I need a GPU that supports tesselation and can output images to the operating system's present engine. Yes, it sounds weird but it looks like there are devices that can't render, at least in theory. In order to check device's _"presentability"_ I need some information about render surface. In `Vulkan` this information stored in http://vulkan-spec-chunked.ahcox.com/ch29s02.html[`VkSurfaceKHR`] object and I need to get this object. Fortunately with `GLFW` library this is an easy task. 

https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstance.html[`VkInstance`] is an entity that keeps the state of the application and is used almost in every other `Vulkan` function. I can create one with https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateInstance.html[`vkCreateInstance`] function:

----
VkResult vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);
----

Finally I'm at the leaf node, no more unknown variables! And I already forgot why do I need all this... Ah, I wanted to create `Shader Modules`.

To summarize: here's the dependency chain:

----
VkShaderModule ðŸ¡¢ VkDevice ðŸ¡¢ VkPhysicalDevice ðŸ¡¢ VkInstance
                              â””ðŸ¡¢ VkSurfaceKHR 
----

And here's how this chain managed in the code:

----
// MainApplication.cpp
MaybeAppData maybeAppData{MaybeAppData{get_required_window_extensions(_appData)}
                                      .and_then(create_instance)
                                      .and_then(create_surface)
                                      .and_then(get_physical_device)
                                      .and_then(create_logical_device)
                                      .and_then(create_shader_modules)};
----

Here `MaybeAppData` is an alias to `tl::expected` (a library as a replacement for non-existent yet `std::expected`, see the https://TODO[previous article]).

----
using MaybeAppData = tl::expected<AppData, std::string>;
----
